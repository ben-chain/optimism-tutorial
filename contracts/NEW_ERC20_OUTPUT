compiled IR
replacing opcode address
replaced opcode address
replacing opcode call
replaced opcode call
replacing opcode staticcall
replaced opcode staticcall
replacing opcode delegatecall
replaced opcode delegatecall
replacing opcode caller
replaced opcode caller
replacing opcode callvalue
replaced opcode callvalue
replacing opcode chainid
replaced opcode chainid
replacing opcode extcodesize
replaced opcode extcodesize
replacing opcode extcodehash
replaced opcode extcodehash
replacing opcode gaslimit
replaced opcode gaslimit
replacing opcode number
replaced opcode number
replacing opcode revert
replaced opcode revert
replacing opcode sload
replaced opcode sload
replacing opcode sstore
replaced opcode sstore
replacing opcode timestamp
replaced opcode timestamp
did replacement

/*******************************************************
 *                       WARNING                       *
 *  Solidity to Yul compilation is still EXPERIMENTAL  *
 *       It can result in LOSS OF FUNDS or worse       *
 *                !USE AT YOUR OWN RISK!               *
 *******************************************************/


object "ERC20_213" {
    code {
// This is "kall"
function ovm_callManager(arguments, arguments_size, output_area, output_area_size) {
    verbatim_4i_0o(
        hex"336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b",
        arguments,
        arguments_size,
        output_area,
        output_area_size
    )
}

function ovm_kopy(from, from_size, to, to_size) {
    verbatim_4i_0o(
        hex"3350600060045af1",
        from,
        from_size,
        to,
        to_size
    )
}

// Call a manager function with two arguments
function ovm_kall_2i(signature, x, y) {
    let tmp_a := mload(0x00)
    let tmp_b := mload(0x20)
    let tmp_c := mload(0x40)
    mstore(0, signature)
    mstore(4, x)
    mstore(0x24, y)
    ovm_callManager(0, 0x44, 0, 0)
    mstore(0x00, tmp_a)
    mstore(0x20, tmp_b)
    mstore(0x40, tmp_c)
}

// Call a manager function returning one value
function ovm_kall_1o(signature) -> r {
    let tmp_a := mload(0x00)
    mstore(0, signature)
    ovm_callManager(0, 4, 0, 0x20)
    r := mload(0)
    mstore(0, tmp_a)
}

// Call a manager function without arguments
function ovm_kall(signature) {
    let tmp_a := mload(0x00)
    mstore(0, signature)
    ovm_callManager(0, 4, 0, 0)
    mstore(0, tmp_a)
}


// Call a manager function with one argument and one return value
function ovm_kall_1i_1o(signature, x) -> r {
    let tmp_a := mload(0x00)
    let tmp_b := mload(0x20)
    mstore(0, signature)
    mstore(4, x)
    ovm_callManager(0, 0x24, 0, 0x20)
    r := mload(0)
    mstore(0x00, tmp_a)
    mstore(0x20, tmp_b)
}

function ovm_kall_dyn(signature, gasIn, addr, argsOffset, argsLength, retOffset, retLength) -> success {
    // TODO If the check fails, we have to use the MSIZE trick or move some
    // memory contents around.

    // Prepend data in front of the actual call data.
    let prefixSize := 0x84
    if iszero(argsLength) {
        // TODO we could do other optimizations.
        argsOffset := prefixSize
    }
    if lt(argsOffset, prefixSize) {
        // TODO find another way
        invalid()
    }

    let callBytes := sub(argsOffset, prefixSize)

    // save data in local variables before it is overwritten
    let tmp_a := mload(add(callBytes, 0x00))
    mstore(add(callBytes, 0), signature)
    let tmp_b := mload(add(callBytes, 0x20))
    let tmp_c := mload(add(callBytes, 0x40))
    mstore(add(callBytes, 0x04), gasIn)
    let tmp_d := mload(add(callBytes, 0x60))
    mstore(add(callBytes, 0x24), addr)
    let tmp_e := mload(add(callBytes, 0x80))
    mstore(add(callBytes, 0x44), 0x60)
    mstore(add(callBytes, 0x64), argsLength)

    // kall, only grabbing 3 words of returndata (success & abi encoding params) and just throw on top of where we put it (successfull kall will awlays return >= 0x60 bytes)
    // overpad calldata by a word (argsLen [raw data] + 0x84 [abi prefixing] + 0x20 [1 word max to pad] = argsLen + 0xa4) to ensure sufficient right 0-padding for abi encoding
    // TODO Properly right-pad, this needs another local variable, I think.
    ovm_callManager(callBytes, add(argsLength, prefixSize), callBytes, 0x60)

    // restore prefix
    mstore(add(callBytes, 0x80), tmp_e)
    mstore(add(callBytes, 0x60), tmp_d)
    mstore(add(callBytes, 0x20), tmp_b)
    let innerReturndatasize := mload(add(callBytes, 0x40))
    mstore(add(callBytes, 0x40), tmp_c)
    success := mload(callBytes)
    mstore(add(callBytes, 0x00), tmp_a)

    // write actual returned data
	returndatacopy(retOffset, 0x60, retLength)
	// call identity precompile to fix returndatasize
	ovm_kopy(0, innerReturndatasize, 0, innerReturndatasize)
}


function ovm_address() -> r {
    r := ovm_kall_1o(hex"996d79a5")
}

function ovm_call(gasIn, addr, value, argsOffset, argsLength, retOffset, retLength) -> success {
    success := ovm_kall_dyn("85979f76", gasIn, addr, argsOffset, argsLength, retOffset, retLength)
}

function ovm_staticcall(gasIn, addr, argsOffset, argsLength, retOffset, retLength) -> success {
    success := ovm_kall_dyn("8540661f", gasIn, addr, argsOffset, argsLength, retOffset, retLength)
}

function ovm_delegatecall(gasIn, addr, argsOffset, argsLength, retOffset, retLength) -> success {
    success := ovm_kall_dyn("ffe73914", gasIn, addr, argsOffset, argsLength, retOffset, retLength)
}

function ovm_caller() -> r {
    r := ovm_kall_1o(hex"73509064")
}

function ovm_callvalue() -> v {
    // we assume no Ether is sent
}

function ovm_chainid() -> r {
    r := ovm_kall_1o(hex"73509064")
}

function ovm_extcodehash(a) -> r {
    r := ovm_kall_1i_1o(hex"24749d5c", a)
}

function ovm_extcodesize(a) -> r {
    r := ovm_kall_1i_1o(hex"8435035b", a)
}

function ovm_gaslimit() -> r {
    r := ovm_kall_1o(hex"20160f3a")
}

// TODO where is this used?
function ovm_getnonce() -> r {
    r := ovm_kall_1o(hex"c1fb2ea2")
}

// TODO where is this used?
function ovm_incrementnonce() {
    ovm_kall(hex"7cebbe94")
}

function ovm_number() -> r {
    r := ovm_kall_1o(hex"5a98c361")
}

function ovm_revert(data, length) {
    let prefixSize := 0x64
    if iszero(length) {
        // TODO optimize further?
        data := prefixSize
    }
    let signature := "2a2a7adb"

    // TODO If the check fails, we have to use the MSIZE trick or move some
    // memory contents around.

    // Prepend data in front of the actual call data.
    if lt(data, prefixSize) {
        // TODO find another way
        invalid()
    }

    let callBytes := sub(data, prefixSize)

    mstore(add(callBytes, 0), signature)
    mstore(add(callBytes, 0x04), 0x20)
    mstore(add(callBytes, 0x24), length)
    ovm_callManager(callBytes, add(length, prefixSize), 0, 0)
    // the verbatim bytecode should revert.
    invalid()
}

function ovm_sload(s) -> r {
    r := ovm_kall_1i_1o(hex"03daa959", s)
}

function ovm_sstore(x, y) {
    ovm_kall_2i(hex"22bd64c0", x, y)
}

function ovm_timestamp() -> r {
    r := ovm_kall_1o(hex"bdbf8c36")
}


        mstore(64, 128)
        if ovm_callvalue() { ovm_revert(0, 0) }

        let _1, _2 := copy_arguments_for_constructor_56_object_ERC20_213()
        constructor_ERC20_213(_1, _2)

        codecopy(0, dataoffset("ERC20_213_deployed"), datasize("ERC20_213_deployed"))

        return(0, datasize("ERC20_213_deployed"))

        function abi_decode_available_length_t_string_memory_ptr_fromMemory(src, length, end) -> array {
            array := allocate_memory(array_allocation_size_t_string_memory_ptr(length))
            mstore(array, length)
            let dst := add(array, 0x20)
            if gt(add(src, length), end) { ovm_revert(0, 0) }
            copy_memory_to_memory(src, dst, length)
        }

        // string
        function abi_decode_t_string_memory_ptr_fromMemory(offset, end) -> array {
            if iszero(slt(add(offset, 0x1f), end)) { ovm_revert(0, 0) }
            let length := mload(offset)
            array := abi_decode_available_length_t_string_memory_ptr_fromMemory(add(offset, 0x20), length, end)
        }

        function abi_decode_t_uint256_fromMemory(offset, end) -> value {
            value := mload(offset)
            validator_revert_t_uint256(value)
        }

        function abi_decode_tuple_t_uint256t_string_memory_ptr_fromMemory(headStart, dataEnd) -> value0, value1 {
            if slt(sub(dataEnd, headStart), 64) { ovm_revert(0, 0) }

            {

                let offset := 0

                value0 := abi_decode_t_uint256_fromMemory(add(headStart, offset), dataEnd)
            }

            {

                let offset := mload(add(headStart, 32))
                if gt(offset, 0xffffffffffffffff) { ovm_revert(0, 0) }

                value1 := abi_decode_t_string_memory_ptr_fromMemory(add(headStart, offset), dataEnd)
            }

        }

        function allocate_memory(size) -> memPtr {
            memPtr := allocate_unbounded()
            finalize_allocation(memPtr, size)
        }

        function allocate_unbounded() -> memPtr {
            memPtr := mload(64)
        }

        function array_allocation_size_t_string_memory_ptr(length) -> size {
            // Make sure we can allocate memory without overflow
            if gt(length, 0xffffffffffffffff) { panic_error_0x41() }

            size := round_up_to_mul_of_32(length)

            // add length slot
            size := add(size, 0x20)

        }

        function array_dataslot_t_string_storage(ptr) -> data {
            data := ptr

            mstore(0, ptr)
            data := keccak256(0, 0x20)

        }

        function array_length_t_string_memory_ptr(value) -> length {

            length := mload(value)

        }

        function cleanup_t_uint160(value) -> cleaned {
            cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
        }

        function cleanup_t_uint256(value) -> cleaned {
            cleaned := value
        }

        function clear_storage_range_t_bytes1(start, end) {
            for {} lt(start, end) { start := add(start, 1) }
            {
                storage_set_to_zero_t_uint256(start, 0)
            }
        }

        function constructor_ERC20_213(var__initialSupply_35, var__name_37_mpos) {

            let _3 := var__initialSupply_35
            let expr_44 := _3
            let _4 := 0x00
            let expr_40 := _4
            let expr_42 := ovm_caller()
            let _5 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_40,expr_42)
            update_storage_value_offset_0t_uint256_to_t_uint256(_5, expr_44)
            let expr_45 := expr_44
            let _6 := var__initialSupply_35
            let expr_48 := _6
            update_storage_value_offset_0t_uint256_to_t_uint256(0x02, expr_48)
            let expr_49 := expr_48
            let _7_mpos := var__name_37_mpos
            let expr_52_mpos := _7_mpos
            update_storage_value_offset_0t_string_memory_ptr_to_t_string_storage(0x03, expr_52_mpos)
            let _8_slot := 0x03
            let expr_53_slot := _8_slot

        }

        function convert_t_address_to_t_ovm_address(value) -> converted {
            converted := convert_t_uint160_to_t_ovm_address(value)
        }

        function convert_t_uint160_to_t_ovm_address(value) -> converted {
            converted := convert_t_uint160_to_t_uint160(value)
        }

        function convert_t_uint160_to_t_uint160(value) -> converted {
            converted := cleanup_t_uint160(value)
        }

        function convert_t_uint256_to_t_uint256(value) -> converted {
            converted := cleanup_t_uint256(value)
        }

        function copy_arguments_for_constructor_56_object_ERC20_213() -> ret_param_0, ret_param_1 {
            let programSize := datasize("ERC20_213")
            let argSize := sub(codesize(), programSize)

            let memoryDataOffset := allocate_memory(argSize)
            codecopy(memoryDataOffset, programSize, argSize)

            ret_param_0, ret_param_1 := abi_decode_tuple_t_uint256t_string_memory_ptr_fromMemory(memoryDataOffset, add(memoryDataOffset, argSize))
        }

        function copy_byte_array_to_storage_from_t_string_memory_ptr_to_t_string_storage(slot, src) {

            let newLen := array_length_t_string_memory_ptr(src)
            // Make sure array length is sane
            if gt(newLen, 0xffffffffffffffff) { panic_error_0x41() }

            let oldLen := extract_byte_array_length(ovm_sload(slot))

            let srcOffset := 0

            srcOffset := 0x20

            // This is not needed in all branches.
            let dstDataArea
            if or(gt(oldLen, 31), gt(newLen, 31)) {
                dstDataArea := array_dataslot_t_string_storage(slot)
            }

            if gt(oldLen, 31) {
                // potentially truncate data
                let deleteStart := add(dstDataArea, div(add(newLen, 31), 32))
                if lt(newLen, 32) { deleteStart := dstDataArea }
                clear_storage_range_t_bytes1(deleteStart, add(dstDataArea, div(add(oldLen, 31), 32)))
            }
            switch gt(newLen, 31)
            case 1 {
                let loopEnd := and(newLen, not(0x1f))

                let dstPtr := dstDataArea
                let i := 0
                for { } lt(i, loopEnd) { i := add(i, 0x20) } {
                    ovm_sstore(dstPtr, mload(add(src, srcOffset)))
                    dstPtr := add(dstPtr, 1)
                    srcOffset := add(srcOffset, 32)
                }
                if lt(loopEnd, newLen) {
                    let lastValue := mload(add(src, srcOffset))
                    ovm_sstore(dstPtr, mask_bytes_dynamic(lastValue, and(newLen, 0x1f)))
                }
                ovm_sstore(slot, add(mul(newLen, 2), 1))
            }
            default {
                let value := 0
                if newLen {
                    value := mload(add(src, srcOffset))
                }
                ovm_sstore(slot, extract_used_part_and_set_length_of_short_byte_array(value, newLen))
            }
        }

        function copy_memory_to_memory(src, dst, length) {
            let i := 0
            for { } lt(i, length) { i := add(i, 32) }
            {
                mstore(add(dst, i), mload(add(src, i)))
            }
            if gt(i, length)
            {
                // clear end
                mstore(add(dst, length), 0)
            }
        }

        function extract_byte_array_length(data) -> length {
            length := div(data, 2)
            let outOfPlaceEncoding := and(data, 1)
            if iszero(outOfPlaceEncoding) {
                length := and(length, 0x7f)
            }

            if eq(outOfPlaceEncoding, lt(length, 32)) {
                panic_error_0x22()
            }
        }

        function extract_used_part_and_set_length_of_short_byte_array(data, len) -> used {
            // we want to save only elements that are part of the array after resizing
            // others should be set to zero
            data := mask_bytes_dynamic(data, len)
            used := or(data, mul(2, len))
        }
        function finalize_allocation(memPtr, size) {
            let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))
            // protect against overflow
            if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr)) { panic_error_0x41() }
            mstore(64, newFreePtr)
        }

        function mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(slot , key) -> dataSlot {
            mstore(0, convert_t_address_to_t_ovm_address(key))
            mstore(0x20, slot)
            dataSlot := keccak256(0, 0x40)
        }

        function mask_bytes_dynamic(data, bytes) -> result {
            let mask := not(shift_right_unsigned_dynamic(mul(8, bytes), not(0)))
            result := and(data, mask)
        }
        function panic_error_0x00() {
            mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
            mstore(4, 0x00)
            ovm_revert(0, 0x24)
        }

        function panic_error_0x22() {
            mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
            mstore(4, 0x22)
            ovm_revert(0, 0x24)
        }

        function panic_error_0x41() {
            mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
            mstore(4, 0x41)
            ovm_revert(0, 0x24)
        }

        function prepare_store_t_uint256(value) -> ret {
            ret := value
        }

        function round_up_to_mul_of_32(value) -> result {
            result := and(add(value, 31), not(31))
        }

        function shift_left_0(value) -> newValue {
            newValue :=

            shl(0, value)

        }

        function shift_left_dynamic(bits, value) -> newValue {
            newValue :=

            shl(bits, value)

        }

        function shift_right_unsigned_dynamic(bits, value) -> newValue {
            newValue :=

            shr(bits, value)

        }

        function storage_set_to_zero_t_uint256(slot, offset) {
            let zero_0 := zero_value_for_split_t_uint256()
            update_storage_value_t_uint256_to_t_uint256(slot, offset, zero_0)
        }

        function update_byte_slice_32_shift_0(value, toInsert) -> result {
            let mask := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
            toInsert := shift_left_0(toInsert)
            value := and(value, not(mask))
            result := or(value, and(toInsert, mask))
        }

        function update_byte_slice_dynamic32(value, shiftBytes, toInsert) -> result {
            let shiftBits := mul(shiftBytes, 8)
            let mask := shift_left_dynamic(shiftBits, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            toInsert := shift_left_dynamic(shiftBits, toInsert)
            value := and(value, not(mask))
            result := or(value, and(toInsert, mask))
        }

        function update_storage_value_offset_0t_string_memory_ptr_to_t_string_storage(slot, value_0) {

            copy_byte_array_to_storage_from_t_string_memory_ptr_to_t_string_storage(slot, value_0)
        }

        function update_storage_value_offset_0t_uint256_to_t_uint256(slot, value_0) {
            let convertedValue_0 := convert_t_uint256_to_t_uint256(value_0)
            ovm_sstore(slot, update_byte_slice_32_shift_0(ovm_sload(slot), prepare_store_t_uint256(convertedValue_0)))
        }

        function update_storage_value_t_uint256_to_t_uint256(slot, offset, value_0) {
            let convertedValue_0 := convert_t_uint256_to_t_uint256(value_0)
            ovm_sstore(slot, update_byte_slice_dynamic32(ovm_sload(slot), offset, prepare_store_t_uint256(convertedValue_0)))
        }

        function validator_revert_t_uint256(value) {
            if iszero(eq(value, cleanup_t_uint256(value))) { ovm_revert(0, 0) }
        }

        function zero_value_for_split_t_uint256() -> ret {
            ret := 0
        }

    }
    object "ERC20_213_deployed" {
        code {
// This is "kall"
function ovm_callManager(arguments, arguments_size, output_area, output_area_size) {
    verbatim_4i_0o(
        hex"336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b",
        arguments,
        arguments_size,
        output_area,
        output_area_size
    )
}

function ovm_kopy(from, from_size, to, to_size) {
    verbatim_4i_0o(
        hex"3350600060045af1",
        from,
        from_size,
        to,
        to_size
    )
}

// Call a manager function with two arguments
function ovm_kall_2i(signature, x, y) {
    let tmp_a := mload(0x00)
    let tmp_b := mload(0x20)
    let tmp_c := mload(0x40)
    mstore(0, signature)
    mstore(4, x)
    mstore(0x24, y)
    ovm_callManager(0, 0x44, 0, 0)
    mstore(0x00, tmp_a)
    mstore(0x20, tmp_b)
    mstore(0x40, tmp_c)
}

// Call a manager function returning one value
function ovm_kall_1o(signature) -> r {
    let tmp_a := mload(0x00)
    mstore(0, signature)
    ovm_callManager(0, 4, 0, 0x20)
    r := mload(0)
    mstore(0, tmp_a)
}

// Call a manager function without arguments
function ovm_kall(signature) {
    let tmp_a := mload(0x00)
    mstore(0, signature)
    ovm_callManager(0, 4, 0, 0)
    mstore(0, tmp_a)
}


// Call a manager function with one argument and one return value
function ovm_kall_1i_1o(signature, x) -> r {
    let tmp_a := mload(0x00)
    let tmp_b := mload(0x20)
    mstore(0, signature)
    mstore(4, x)
    ovm_callManager(0, 0x24, 0, 0x20)
    r := mload(0)
    mstore(0x00, tmp_a)
    mstore(0x20, tmp_b)
}

function ovm_kall_dyn(signature, gasIn, addr, argsOffset, argsLength, retOffset, retLength) -> success {
    // TODO If the check fails, we have to use the MSIZE trick or move some
    // memory contents around.

    // Prepend data in front of the actual call data.
    let prefixSize := 0x84
    if iszero(argsLength) {
        // TODO we could do other optimizations.
        argsOffset := prefixSize
    }
    if lt(argsOffset, prefixSize) {
        // TODO find another way
        invalid()
    }

    let callBytes := sub(argsOffset, prefixSize)

    // save data in local variables before it is overwritten
    let tmp_a := mload(add(callBytes, 0x00))
    mstore(add(callBytes, 0), signature)
    let tmp_b := mload(add(callBytes, 0x20))
    let tmp_c := mload(add(callBytes, 0x40))
    mstore(add(callBytes, 0x04), gasIn)
    let tmp_d := mload(add(callBytes, 0x60))
    mstore(add(callBytes, 0x24), addr)
    let tmp_e := mload(add(callBytes, 0x80))
    mstore(add(callBytes, 0x44), 0x60)
    mstore(add(callBytes, 0x64), argsLength)

    // kall, only grabbing 3 words of returndata (success & abi encoding params) and just throw on top of where we put it (successfull kall will awlays return >= 0x60 bytes)
    // overpad calldata by a word (argsLen [raw data] + 0x84 [abi prefixing] + 0x20 [1 word max to pad] = argsLen + 0xa4) to ensure sufficient right 0-padding for abi encoding
    // TODO Properly right-pad, this needs another local variable, I think.
    ovm_callManager(callBytes, add(argsLength, prefixSize), callBytes, 0x60)

    // restore prefix
    mstore(add(callBytes, 0x80), tmp_e)
    mstore(add(callBytes, 0x60), tmp_d)
    mstore(add(callBytes, 0x20), tmp_b)
    let innerReturndatasize := mload(add(callBytes, 0x40))
    mstore(add(callBytes, 0x40), tmp_c)
    success := mload(callBytes)
    mstore(add(callBytes, 0x00), tmp_a)

    // write actual returned data
	returndatacopy(retOffset, 0x60, retLength)
	// call identity precompile to fix returndatasize
	ovm_kopy(0, innerReturndatasize, 0, innerReturndatasize)
}


function ovm_address() -> r {
    r := ovm_kall_1o(hex"996d79a5")
}

function ovm_call(gasIn, addr, value, argsOffset, argsLength, retOffset, retLength) -> success {
    success := ovm_kall_dyn("85979f76", gasIn, addr, argsOffset, argsLength, retOffset, retLength)
}

function ovm_staticcall(gasIn, addr, argsOffset, argsLength, retOffset, retLength) -> success {
    success := ovm_kall_dyn("8540661f", gasIn, addr, argsOffset, argsLength, retOffset, retLength)
}

function ovm_delegatecall(gasIn, addr, argsOffset, argsLength, retOffset, retLength) -> success {
    success := ovm_kall_dyn("ffe73914", gasIn, addr, argsOffset, argsLength, retOffset, retLength)
}

function ovm_caller() -> r {
    r := ovm_kall_1o(hex"73509064")
}

function ovm_callvalue() -> v {
    // we assume no Ether is sent
}

function ovm_chainid() -> r {
    r := ovm_kall_1o(hex"73509064")
}

function ovm_extcodehash(a) -> r {
    r := ovm_kall_1i_1o(hex"24749d5c", a)
}

function ovm_extcodesize(a) -> r {
    r := ovm_kall_1i_1o(hex"8435035b", a)
}

function ovm_gaslimit() -> r {
    r := ovm_kall_1o(hex"20160f3a")
}

// TODO where is this used?
function ovm_getnonce() -> r {
    r := ovm_kall_1o(hex"c1fb2ea2")
}

// TODO where is this used?
function ovm_incrementnonce() {
    ovm_kall(hex"7cebbe94")
}

function ovm_number() -> r {
    r := ovm_kall_1o(hex"5a98c361")
}

function ovm_revert(data, length) {
    let prefixSize := 0x64
    if iszero(length) {
        // TODO optimize further?
        data := prefixSize
    }
    let signature := "2a2a7adb"

    // TODO If the check fails, we have to use the MSIZE trick or move some
    // memory contents around.

    // Prepend data in front of the actual call data.
    if lt(data, prefixSize) {
        // TODO find another way
        invalid()
    }

    let callBytes := sub(data, prefixSize)

    mstore(add(callBytes, 0), signature)
    mstore(add(callBytes, 0x04), 0x20)
    mstore(add(callBytes, 0x24), length)
    ovm_callManager(callBytes, add(length, prefixSize), 0, 0)
    // the verbatim bytecode should revert.
    invalid()
}

function ovm_sload(s) -> r {
    r := ovm_kall_1i_1o(hex"03daa959", s)
}

function ovm_sstore(x, y) {
    ovm_kall_2i(hex"22bd64c0", x, y)
}

function ovm_timestamp() -> r {
    r := ovm_kall_1o(hex"bdbf8c36")
}


            mstore(64, 128)

            if iszero(lt(calldatasize(), 4))
            {
                let selector := shift_right_224_unsigned(calldataload(0))
                switch selector

                case 0x06fdde03
                {
                    // name()

                    if ovm_callvalue() { ovm_revert(0, 0) }
                    abi_decode_tuple_(4, calldatasize())
                    let ret_0 :=  getter_fun_name_32()
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack(memPos , ret_0)
                    return(memPos, sub(memEnd, memPos))
                }

                case 0x095ea7b3
                {
                    // approve(address,uint256)

                    if ovm_callvalue() { ovm_revert(0, 0) }
                    let param_0, param_1 :=  abi_decode_tuple_t_addresst_uint256(4, calldatasize())
                    let ret_0 :=  fun_approve_195(param_0, param_1)
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple_t_bool__to_t_bool__fromStack(memPos , ret_0)
                    return(memPos, sub(memEnd, memPos))
                }

                case 0x18160ddd
                {
                    // totalSupply()

                    if ovm_callvalue() { ovm_revert(0, 0) }
                    abi_decode_tuple_(4, calldatasize())
                    let ret_0 :=  getter_fun_totalSupply_30()
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple_t_uint256__to_t_uint256__fromStack(memPos , ret_0)
                    return(memPos, sub(memEnd, memPos))
                }

                case 0x23b872dd
                {
                    // transferFrom(address,address,uint256)

                    if ovm_callvalue() { ovm_revert(0, 0) }
                    let param_0, param_1, param_2 :=  abi_decode_tuple_t_addresst_addresst_uint256(4, calldatasize())
                    let ret_0 :=  fun_transferFrom_166(param_0, param_1, param_2)
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple_t_bool__to_t_bool__fromStack(memPos , ret_0)
                    return(memPos, sub(memEnd, memPos))
                }

                case 0x27e235e3
                {
                    // balances(address)

                    if ovm_callvalue() { ovm_revert(0, 0) }
                    let param_0 :=  abi_decode_tuple_t_ovm_address(4, calldatasize())
                    let ret_0 :=  getter_fun_balances_22(param_0)
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple_t_uint256__to_t_uint256__fromStack(memPos , ret_0)
                    return(memPos, sub(memEnd, memPos))
                }

                case 0x55b6ed5c
                {
                    // allowances(address,address)

                    if ovm_callvalue() { ovm_revert(0, 0) }
                    let param_0, param_1 :=  abi_decode_tuple_t_addresst_ovm_address(4, calldatasize())
                    let ret_0 :=  getter_fun_allowances_28(param_0, param_1)
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple_t_uint256__to_t_uint256__fromStack(memPos , ret_0)
                    return(memPos, sub(memEnd, memPos))
                }

                case 0x70a08231
                {
                    // balanceOf(address)

                    if ovm_callvalue() { ovm_revert(0, 0) }
                    let param_0 :=  abi_decode_tuple_t_ovm_address(4, calldatasize())
                    let ret_0 :=  fun_balanceOf_69(param_0)
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple_t_uint256__to_t_uint256__fromStack(memPos , ret_0)
                    return(memPos, sub(memEnd, memPos))
                }

                case 0xa9059cbb
                {
                    // transfer(address,uint256)

                    if ovm_callvalue() { ovm_revert(0, 0) }
                    let param_0, param_1 :=  abi_decode_tuple_t_addresst_uint256(4, calldatasize())
                    let ret_0 :=  fun_transfer_112(param_0, param_1)
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple_t_bool__to_t_bool__fromStack(memPos , ret_0)
                    return(memPos, sub(memEnd, memPos))
                }

                case 0xdd62ed3e
                {
                    // allowance(address,address)

                    if ovm_callvalue() { ovm_revert(0, 0) }
                    let param_0, param_1 :=  abi_decode_tuple_t_addresst_ovm_address(4, calldatasize())
                    let ret_0 :=  fun_allowance_212(param_0, param_1)
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple_t_uint256__to_t_uint256__fromStack(memPos , ret_0)
                    return(memPos, sub(memEnd, memPos))
                }

                default {}
            }
            if iszero(calldatasize()) {  }
            ovm_revert(0, 0)

            function abi_decode_t_ovm_address(offset, end) -> value {
                value := calldataload(offset)
                validator_revert_t_ovm_address(value)
            }

            function abi_decode_t_uint256(offset, end) -> value {
                value := calldataload(offset)
                validator_revert_t_uint256(value)
            }

            function abi_decode_tuple_(headStart, dataEnd)   {
                if slt(sub(dataEnd, headStart), 0) { ovm_revert(0, 0) }

            }

            function abi_decode_tuple_t_ovm_address(headStart, dataEnd) -> value0 {
                if slt(sub(dataEnd, headStart), 32) { ovm_revert(0, 0) }

                {

                    let offset := 0

                    value0 := abi_decode_t_ovm_address(add(headStart, offset), dataEnd)
                }

            }

            function abi_decode_tuple_t_addresst_ovm_address(headStart, dataEnd) -> value0, value1 {
                if slt(sub(dataEnd, headStart), 64) { ovm_revert(0, 0) }

                {

                    let offset := 0

                    value0 := abi_decode_t_ovm_address(add(headStart, offset), dataEnd)
                }

                {

                    let offset := 32

                    value1 := abi_decode_t_ovm_address(add(headStart, offset), dataEnd)
                }

            }

            function abi_decode_tuple_t_addresst_addresst_uint256(headStart, dataEnd) -> value0, value1, value2 {
                if slt(sub(dataEnd, headStart), 96) { ovm_revert(0, 0) }

                {

                    let offset := 0

                    value0 := abi_decode_t_ovm_address(add(headStart, offset), dataEnd)
                }

                {

                    let offset := 32

                    value1 := abi_decode_t_ovm_address(add(headStart, offset), dataEnd)
                }

                {

                    let offset := 64

                    value2 := abi_decode_t_uint256(add(headStart, offset), dataEnd)
                }

            }

            function abi_decode_tuple_t_addresst_uint256(headStart, dataEnd) -> value0, value1 {
                if slt(sub(dataEnd, headStart), 64) { ovm_revert(0, 0) }

                {

                    let offset := 0

                    value0 := abi_decode_t_ovm_address(add(headStart, offset), dataEnd)
                }

                {

                    let offset := 32

                    value1 := abi_decode_t_uint256(add(headStart, offset), dataEnd)
                }

            }

            function abi_encodeUpdatedPos_t_string_storage_to_t_string_memory_ptr(value0, pos) -> updatedPos {
                updatedPos := abi_encode_t_string_storage_to_t_string_memory_ptr(value0, pos)
            }

            function abi_encode_t_bool_to_t_bool_fromStack(value, pos) {
                mstore(pos, cleanup_t_bool(value))
            }

            function abi_encode_t_string_memory_ptr_to_t_string_memory_ptr_fromStack(value, pos) -> end {
                let length := array_length_t_string_memory_ptr(value)
                pos := array_storeLengthForEncoding_t_string_memory_ptr_fromStack(pos, length)
                copy_memory_to_memory(add(value, 0x20), pos, length)
                end := add(pos, round_up_to_mul_of_32(length))
            }

            // string -> string
            function abi_encode_t_string_storage_to_t_string_memory_ptr(value, pos) -> ret {
                let slotValue := ovm_sload(value)
                let length := extract_byte_array_length(slotValue)
                pos := array_storeLengthForEncoding_t_string_memory_ptr(pos, length)
                switch and(slotValue, 1)
                case 0 {
                    // short byte array
                    mstore(pos, and(slotValue, not(0xff)))
                    ret := add(pos, 0x20)
                }
                case 1 {
                    // long byte array
                    let dataPos := array_dataslot_t_string_storage(value)
                    let i := 0
                    for { } lt(i, length) { i := add(i, 0x20) } {
                        mstore(add(pos, i), ovm_sload(dataPos))
                        dataPos := add(dataPos, 1)
                    }
                    ret := add(pos, i)
                }
            }

            function abi_encode_t_stringliteral_0e5b6496164dcbcdb9d30a74fcec2c61077c98a207a5b4dfebe5ed787438461e_to_t_string_memory_ptr_fromStack(pos) -> end {
                pos := array_storeLengthForEncoding_t_string_memory_ptr_fromStack(pos, 86)
                store_literal_in_memory_0e5b6496164dcbcdb9d30a74fcec2c61077c98a207a5b4dfebe5ed787438461e(pos)
                end := add(pos, 96)
            }

            function abi_encode_t_stringliteral_849f4faab16c011d467f39c99aecef945e8495191084f06c07bdad4d301e8ad5_to_t_string_memory_ptr_fromStack(pos) -> end {
                pos := array_storeLengthForEncoding_t_string_memory_ptr_fromStack(pos, 79)
                store_literal_in_memory_849f4faab16c011d467f39c99aecef945e8495191084f06c07bdad4d301e8ad5(pos)
                end := add(pos, 96)
            }

            function abi_encode_t_stringliteral_f6dc75474749581397913169c9c25a751245831259e1dcd5dfe173441b4f6290_to_t_string_memory_ptr_fromStack(pos) -> end {
                pos := array_storeLengthForEncoding_t_string_memory_ptr_fromStack(pos, 52)
                store_literal_in_memory_f6dc75474749581397913169c9c25a751245831259e1dcd5dfe173441b4f6290(pos)
                end := add(pos, 64)
            }

            function abi_encode_t_uint256_to_t_uint256_fromStack(value, pos) {
                mstore(pos, cleanup_t_uint256(value))
            }

            function abi_encode_tuple_t_bool__to_t_bool__fromStack(headStart , value0) -> tail {
                tail := add(headStart, 32)

                abi_encode_t_bool_to_t_bool_fromStack(value0,  add(headStart, 0))

            }

            function abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack(headStart , value0) -> tail {
                tail := add(headStart, 32)

                mstore(add(headStart, 0), sub(tail, headStart))
                tail := abi_encode_t_string_memory_ptr_to_t_string_memory_ptr_fromStack(value0,  tail)

            }

            function abi_encode_tuple_t_stringliteral_0e5b6496164dcbcdb9d30a74fcec2c61077c98a207a5b4dfebe5ed787438461e__to_t_string_memory_ptr__fromStack(headStart ) -> tail {
                tail := add(headStart, 32)

                mstore(add(headStart, 0), sub(tail, headStart))
                tail := abi_encode_t_stringliteral_0e5b6496164dcbcdb9d30a74fcec2c61077c98a207a5b4dfebe5ed787438461e_to_t_string_memory_ptr_fromStack( tail)

            }

            function abi_encode_tuple_t_stringliteral_849f4faab16c011d467f39c99aecef945e8495191084f06c07bdad4d301e8ad5__to_t_string_memory_ptr__fromStack(headStart ) -> tail {
                tail := add(headStart, 32)

                mstore(add(headStart, 0), sub(tail, headStart))
                tail := abi_encode_t_stringliteral_849f4faab16c011d467f39c99aecef945e8495191084f06c07bdad4d301e8ad5_to_t_string_memory_ptr_fromStack( tail)

            }

            function abi_encode_tuple_t_stringliteral_f6dc75474749581397913169c9c25a751245831259e1dcd5dfe173441b4f6290__to_t_string_memory_ptr__fromStack(headStart ) -> tail {
                tail := add(headStart, 32)

                mstore(add(headStart, 0), sub(tail, headStart))
                tail := abi_encode_t_stringliteral_f6dc75474749581397913169c9c25a751245831259e1dcd5dfe173441b4f6290_to_t_string_memory_ptr_fromStack( tail)

            }

            function abi_encode_tuple_t_uint256__to_t_uint256__fromStack(headStart , value0) -> tail {
                tail := add(headStart, 32)

                abi_encode_t_uint256_to_t_uint256_fromStack(value0,  add(headStart, 0))

            }

            function allocate_unbounded() -> memPtr {
                memPtr := mload(64)
            }

            function array_dataslot_t_string_storage(ptr) -> data {
                data := ptr

                mstore(0, ptr)
                data := keccak256(0, 0x20)

            }

            function array_length_t_string_memory_ptr(value) -> length {

                length := mload(value)

            }

            function array_storeLengthForEncoding_t_string_memory_ptr(pos, length) -> updated_pos {
                mstore(pos, length)
                updated_pos := add(pos, 0x20)
            }

            function array_storeLengthForEncoding_t_string_memory_ptr_fromStack(pos, length) -> updated_pos {
                mstore(pos, length)
                updated_pos := add(pos, 0x20)
            }

            function checked_add_t_uint256(x, y) -> sum {
                x := cleanup_t_uint256(x)
                y := cleanup_t_uint256(y)

                // overflow, if x > (maxValue - y)
                if gt(x, sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, y)) { panic_error_0x11() }

                sum := add(x, y)
            }

            function checked_sub_t_uint256(x, y) -> diff {
                x := cleanup_t_uint256(x)
                y := cleanup_t_uint256(y)

                if lt(x, y) { panic_error_0x11() }

                diff := sub(x, y)
            }

            function cleanup_from_storage_t_uint256(value) -> cleaned {
                cleaned := value
            }

            function cleanup_t_ovm_address(value) -> cleaned {
                cleaned := cleanup_t_uint160(value)
            }

            function cleanup_t_bool(value) -> cleaned {
                cleaned := iszero(iszero(value))
            }

            function cleanup_t_uint160(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
            }

            function cleanup_t_uint256(value) -> cleaned {
                cleaned := value
            }

            function convert_t_address_to_t_ovm_address(value) -> converted {
                converted := convert_t_uint160_to_t_ovm_address(value)
            }

            function convert_t_uint160_to_t_ovm_address(value) -> converted {
                converted := convert_t_uint160_to_t_uint160(value)
            }

            function convert_t_uint160_to_t_uint160(value) -> converted {
                converted := cleanup_t_uint160(value)
            }

            function convert_t_uint256_to_t_uint256(value) -> converted {
                converted := cleanup_t_uint256(value)
            }

            function copy_array_from_storage_to_memory_t_string_storage(slot) -> memPtr {
                memPtr := allocate_unbounded()
                let end := abi_encodeUpdatedPos_t_string_storage_to_t_string_memory_ptr(slot, memPtr)
                finalize_allocation(memPtr, sub(end, memPtr))
            }

            function copy_memory_to_memory(src, dst, length) {
                let i := 0
                for { } lt(i, length) { i := add(i, 32) }
                {
                    mstore(add(dst, i), mload(add(src, i)))
                }
                if gt(i, length)
                {
                    // clear end
                    mstore(add(dst, length), 0)
                }
            }

            function extract_byte_array_length(data) -> length {
                length := div(data, 2)
                let outOfPlaceEncoding := and(data, 1)
                if iszero(outOfPlaceEncoding) {
                    length := and(length, 0x7f)
                }

                if eq(outOfPlaceEncoding, lt(length, 32)) {
                    panic_error_0x22()
                }
            }

            function extract_from_storage_value_dynamict_uint256(slot_value, offset) -> value {
                value := cleanup_from_storage_t_uint256(shift_right_unsigned_dynamic(mul(offset, 8), slot_value))
            }

            function extract_from_storage_value_offset_0t_uint256(slot_value) -> value {
                value := cleanup_from_storage_t_uint256(shift_right_0_unsigned(slot_value))
            }

            function finalize_allocation(memPtr, size) {
                let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))
                // protect against overflow
                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr)) { panic_error_0x41() }
                mstore(64, newFreePtr)
            }

            function fun_allowance_212(var__owner_198, var__spender_200) -> var__203 {
                let zero_t_uint256_66 := zero_value_for_split_t_uint256()
                var__203 := zero_t_uint256_66

                let _67 := 0x01
                let expr_205 := _67
                let _68 := var__owner_198
                let expr_206 := _68
                let _69 := mapping_index_access_t_mapping$_t_address_$_t_mapping$_t_address_$_t_uint256_$_$_of_t_ovm_address(expr_205,expr_206)
                let _70 := _69
                let expr_207 := _70
                let _71 := var__spender_200
                let expr_208 := _71
                let _72 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_207,expr_208)
                let _73 := read_from_storage_split_offset_0_t_uint256(_72)
                let expr_209 := _73
                var__203 := expr_209
                leave

            }

            function fun_approve_195(var__spender_169, var__amount_171) -> var__174 {
                let zero_t_bool_54 := zero_value_for_split_t_bool()
                var__174 := zero_t_bool_54

                let _55 := var__amount_171
                let expr_182 := _55
                let _56 := 0x01
                let expr_176 := _56
                let expr_178 := ovm_caller()
                let _57 := mapping_index_access_t_mapping$_t_address_$_t_mapping$_t_address_$_t_uint256_$_$_of_t_ovm_address(expr_176,expr_178)
                let _58 := _57
                let expr_180 := _58
                let _59 := var__spender_169
                let expr_179 := _59
                let _60 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_180,expr_179)
                update_storage_value_offset_0t_uint256_to_t_uint256(_60, expr_182)
                let expr_183 := expr_182
                let expr_187 := ovm_caller()
                let _61 := var__spender_169
                let expr_188 := _61
                let _62 := var__amount_171
                let expr_189 := _62
                let _63 := 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
                {
                    let _64 := allocate_unbounded()
                    let _65 := abi_encode_tuple_t_uint256__to_t_uint256__fromStack(_64 , expr_189)
                    log3(_64, sub(_65, _64) , _63, expr_187, expr_188)
                }let expr_192 := 0x01
                var__174 := expr_192
                leave

            }

            function fun_balanceOf_69(var__owner_59) -> var__62 {
                let zero_t_uint256_1 := zero_value_for_split_t_uint256()
                var__62 := zero_t_uint256_1

                let _2 := 0x00
                let expr_64 := _2
                let _3 := var__owner_59
                let expr_65 := _3
                let _4 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_64,expr_65)
                let _5 := read_from_storage_split_offset_0_t_uint256(_4)
                let expr_66 := _5
                var__62 := expr_66
                leave

            }

            function fun_transferFrom_166(var__from_115, var__to_117, var__amount_119) -> var__122 {
                let zero_t_bool_25 := zero_value_for_split_t_bool()
                var__122 := zero_t_bool_25

                let _26 := 0x00
                let expr_125 := _26
                let _27 := var__from_115
                let expr_126 := _27
                let _28 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_125,expr_126)
                let _29 := read_from_storage_split_offset_0_t_uint256(_28)
                let expr_127 := _29
                let _30 := var__amount_119
                let expr_128 := _30
                let expr_129 := iszero(lt(cleanup_t_uint256(expr_127), cleanup_t_uint256(expr_128)))
                require_helper_t_stringliteral_849f4faab16c011d467f39c99aecef945e8495191084f06c07bdad4d301e8ad5(expr_129)
                let _31 := 0x01
                let expr_134 := _31
                let _32 := var__from_115
                let expr_135 := _32
                let _33 := mapping_index_access_t_mapping$_t_address_$_t_mapping$_t_address_$_t_uint256_$_$_of_t_ovm_address(expr_134,expr_135)
                let _34 := _33
                let expr_136 := _34
                let expr_138 := ovm_caller()
                let _35 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_136,expr_138)
                let _36 := read_from_storage_split_offset_0_t_uint256(_35)
                let expr_139 := _36
                let _37 := var__amount_119
                let expr_140 := _37
                let expr_141 := iszero(lt(cleanup_t_uint256(expr_139), cleanup_t_uint256(expr_140)))
                require_helper_t_stringliteral_0e5b6496164dcbcdb9d30a74fcec2c61077c98a207a5b4dfebe5ed787438461e(expr_141)
                let _38 := var__amount_119
                let expr_148 := _38
                let _39 := 0x00
                let expr_145 := _39
                let _40 := var__to_117
                let expr_146 := _40
                let _41 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_145,expr_146)
                let _42 := read_from_storage_split_offset_0_t_uint256(_41)
                expr_148 := checked_add_t_uint256(_42, expr_148)
                update_storage_value_offset_0t_uint256_to_t_uint256(_41, expr_148)
                let expr_149 := expr_148
                let _43 := var__amount_119
                let expr_154 := _43
                let _44 := 0x00
                let expr_151 := _44
                let _45 := var__from_115
                let expr_152 := _45
                let _46 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_151,expr_152)
                let _47 := read_from_storage_split_offset_0_t_uint256(_46)
                expr_154 := checked_sub_t_uint256(_47, expr_154)
                update_storage_value_offset_0t_uint256_to_t_uint256(_46, expr_154)
                let expr_155 := expr_154
                let _48 := var__from_115
                let expr_158 := _48
                let _49 := var__to_117
                let expr_159 := _49
                let _50 := var__amount_119
                let expr_160 := _50
                let _51 := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
                {
                    let _52 := allocate_unbounded()
                    let _53 := abi_encode_tuple_t_uint256__to_t_uint256__fromStack(_52 , expr_160)
                    log3(_52, sub(_53, _52) , _51, expr_158, expr_159)
                }let expr_163 := 0x01
                var__122 := expr_163
                leave

            }

            function fun_transfer_112(var__to_72, var__amount_74) -> var__77 {
                let zero_t_bool_6 := zero_value_for_split_t_bool()
                var__77 := zero_t_bool_6

                let _7 := 0x00
                let expr_80 := _7
                let expr_82 := ovm_caller()
                let _8 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_80,expr_82)
                let _9 := read_from_storage_split_offset_0_t_uint256(_8)
                let expr_83 := _9
                let _10 := var__amount_74
                let expr_84 := _10
                let expr_85 := iszero(lt(cleanup_t_uint256(expr_83), cleanup_t_uint256(expr_84)))
                require_helper_t_stringliteral_f6dc75474749581397913169c9c25a751245831259e1dcd5dfe173441b4f6290(expr_85)
                let _11 := var__amount_74
                let expr_93 := _11
                let _12 := 0x00
                let expr_89 := _12
                let expr_91 := ovm_caller()
                let _13 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_89,expr_91)
                let _14 := read_from_storage_split_offset_0_t_uint256(_13)
                expr_93 := checked_sub_t_uint256(_14, expr_93)
                update_storage_value_offset_0t_uint256_to_t_uint256(_13, expr_93)
                let expr_94 := expr_93
                let _15 := var__amount_74
                let expr_99 := _15
                let _16 := 0x00
                let expr_96 := _16
                let _17 := var__to_72
                let expr_97 := _17
                let _18 := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(expr_96,expr_97)
                let _19 := read_from_storage_split_offset_0_t_uint256(_18)
                expr_99 := checked_add_t_uint256(_19, expr_99)
                update_storage_value_offset_0t_uint256_to_t_uint256(_18, expr_99)
                let expr_100 := expr_99
                let expr_104 := ovm_caller()
                let _20 := var__to_72
                let expr_105 := _20
                let _21 := var__amount_74
                let expr_106 := _21
                let _22 := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
                {
                    let _23 := allocate_unbounded()
                    let _24 := abi_encode_tuple_t_uint256__to_t_uint256__fromStack(_23 , expr_106)
                    log3(_23, sub(_24, _23) , _22, expr_104, expr_105)
                }let expr_109 := 0x01
                var__77 := expr_109
                leave

            }

            function getter_fun_allowances_28(key_0, key_1) -> ret {

                let slot := 1
                let offset := 0

                slot := mapping_index_access_t_mapping$_t_address_$_t_mapping$_t_address_$_t_uint256_$_$_of_t_ovm_address(slot, key_0)

                slot := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(slot, key_1)

                ret := read_from_storage_split_dynamic_t_uint256(slot, offset)

            }

            function getter_fun_balances_22(key_0) -> ret {

                let slot := 0
                let offset := 0

                slot := mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(slot, key_0)

                ret := read_from_storage_split_dynamic_t_uint256(slot, offset)

            }

            function getter_fun_name_32() -> ret_mpos {

                let slot := 3
                let offset := 0

                ret_mpos := read_from_storage__dynamic_split_t_string_memory_ptr(slot, offset)

            }

            function getter_fun_totalSupply_30() -> ret {

                let slot := 2
                let offset := 0

                ret := read_from_storage_split_dynamic_t_uint256(slot, offset)

            }

            function mapping_index_access_t_mapping$_t_address_$_t_mapping$_t_address_$_t_uint256_$_$_of_t_ovm_address(slot , key) -> dataSlot {
                mstore(0, convert_t_address_to_t_ovm_address(key))
                mstore(0x20, slot)
                dataSlot := keccak256(0, 0x40)
            }

            function mapping_index_access_t_mapping$_t_address_$_t_uint256_$_of_t_ovm_address(slot , key) -> dataSlot {
                mstore(0, convert_t_address_to_t_ovm_address(key))
                mstore(0x20, slot)
                dataSlot := keccak256(0, 0x40)
            }

            function panic_error_0x00() {
                mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                mstore(4, 0x00)
                ovm_revert(0, 0x24)
            }

            function panic_error_0x11() {
                mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                mstore(4, 0x11)
                ovm_revert(0, 0x24)
            }

            function panic_error_0x22() {
                mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                mstore(4, 0x22)
                ovm_revert(0, 0x24)
            }

            function panic_error_0x41() {
                mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                mstore(4, 0x41)
                ovm_revert(0, 0x24)
            }

            function prepare_store_t_uint256(value) -> ret {
                ret := value
            }

            function read_from_storage__dynamic_split_t_string_memory_ptr(slot, offset) -> value {
                if gt(offset, 0) { panic_error_0x00() }
                value := copy_array_from_storage_to_memory_t_string_storage(slot)
            }

            function read_from_storage_split_dynamic_t_uint256(slot, offset) -> value {
                value := extract_from_storage_value_dynamict_uint256(ovm_sload(slot), offset)

            }

            function read_from_storage_split_offset_0_t_uint256(slot) -> value {
                value := extract_from_storage_value_offset_0t_uint256(ovm_sload(slot))

            }

            function require_helper_t_stringliteral_0e5b6496164dcbcdb9d30a74fcec2c61077c98a207a5b4dfebe5ed787438461e(condition ) {
                if iszero(condition) {
                    let memPtr := allocate_unbounded()
                    mstore(memPtr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                    let end := abi_encode_tuple_t_stringliteral_0e5b6496164dcbcdb9d30a74fcec2c61077c98a207a5b4dfebe5ed787438461e__to_t_string_memory_ptr__fromStack(add(memPtr, 4) )
                    ovm_revert(memPtr, sub(end, memPtr))
                }
            }

            function require_helper_t_stringliteral_849f4faab16c011d467f39c99aecef945e8495191084f06c07bdad4d301e8ad5(condition ) {
                if iszero(condition) {
                    let memPtr := allocate_unbounded()
                    mstore(memPtr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                    let end := abi_encode_tuple_t_stringliteral_849f4faab16c011d467f39c99aecef945e8495191084f06c07bdad4d301e8ad5__to_t_string_memory_ptr__fromStack(add(memPtr, 4) )
                    ovm_revert(memPtr, sub(end, memPtr))
                }
            }

            function require_helper_t_stringliteral_f6dc75474749581397913169c9c25a751245831259e1dcd5dfe173441b4f6290(condition ) {
                if iszero(condition) {
                    let memPtr := allocate_unbounded()
                    mstore(memPtr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                    let end := abi_encode_tuple_t_stringliteral_f6dc75474749581397913169c9c25a751245831259e1dcd5dfe173441b4f6290__to_t_string_memory_ptr__fromStack(add(memPtr, 4) )
                    ovm_revert(memPtr, sub(end, memPtr))
                }
            }

            function round_up_to_mul_of_32(value) -> result {
                result := and(add(value, 31), not(31))
            }

            function shift_left_0(value) -> newValue {
                newValue :=

                shl(0, value)

            }

            function shift_right_0_unsigned(value) -> newValue {
                newValue :=

                shr(0, value)

            }

            function shift_right_224_unsigned(value) -> newValue {
                newValue :=

                shr(224, value)

            }

            function shift_right_unsigned_dynamic(bits, value) -> newValue {
                newValue :=

                shr(bits, value)

            }

            function store_literal_in_memory_0e5b6496164dcbcdb9d30a74fcec2c61077c98a207a5b4dfebe5ed787438461e(memPtr) {

                mstore(add(memPtr, 0), "Can't transfer from the desired ")

                mstore(add(memPtr, 32), "account because you don't have e")

                mstore(add(memPtr, 64), "nough of an allowance.")

            }

            function store_literal_in_memory_849f4faab16c011d467f39c99aecef945e8495191084f06c07bdad4d301e8ad5(memPtr) {

                mstore(add(memPtr, 0), "Can't transfer from the desired ")

                mstore(add(memPtr, 32), "account because it doesn't have ")

                mstore(add(memPtr, 64), "enough balance.")

            }

            function store_literal_in_memory_f6dc75474749581397913169c9c25a751245831259e1dcd5dfe173441b4f6290(memPtr) {

                mstore(add(memPtr, 0), "You don't have enough balance to")

                mstore(add(memPtr, 32), " make this transfer!")

            }

            function update_byte_slice_32_shift_0(value, toInsert) -> result {
                let mask := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                toInsert := shift_left_0(toInsert)
                value := and(value, not(mask))
                result := or(value, and(toInsert, mask))
            }

            function update_storage_value_offset_0t_uint256_to_t_uint256(slot, value_0) {
                let convertedValue_0 := convert_t_uint256_to_t_uint256(value_0)
                ovm_sstore(slot, update_byte_slice_32_shift_0(ovm_sload(slot), prepare_store_t_uint256(convertedValue_0)))
            }

            function validator_revert_t_ovm_address(value) {
                if iszero(eq(value, cleanup_t_ovm_address(value))) { ovm_revert(0, 0) }
            }

            function validator_revert_t_uint256(value) {
                if iszero(eq(value, cleanup_t_uint256(value))) { ovm_revert(0, 0) }
            }

            function zero_value_for_split_t_bool() -> ret {
                ret := 0
            }

            function zero_value_for_split_t_uint256() -> ret {
                ret := 0
            }

        }

    }

}

======= <stdin> (EVM) =======

Pretty printed source:
object "ERC20_213" {
    code {
        {
            mstore(64, 128)
            let programSize := datasize("ERC20_213")
            let argSize := sub(codesize(), programSize)
            let memoryDataOffset := allocate_memory(argSize)
            codecopy(memoryDataOffset, programSize, argSize)
            let _1 := add(memoryDataOffset, argSize)
            if slt(sub(_1, memoryDataOffset), 64) { ovm_revert() }
            let value := mload(memoryDataOffset)
            let _2 := 32
            let offset := mload(add(memoryDataOffset, _2))
            let _3 := sub(shl(64, 1), 1)
            if gt(offset, _3) { ovm_revert() }
            let _4 := add(memoryDataOffset, offset)
            if iszero(slt(add(_4, 0x1f), _1)) { ovm_revert() }
            let _5 := mload(_4)
            if gt(_5, _3) { panic_error_0x41() }
            let array := allocate_memory(add(and(add(_5, 0x1f), not(31)), _2))
            mstore(array, _5)
            if gt(add(add(_4, _5), _2), _1) { ovm_revert() }
            let i := 0
            for { } lt(i, _5) { i := add(i, _2) }
            {
                mstore(add(add(array, i), _2), mload(add(add(_4, i), _2)))
            }
            if gt(i, _5)
            {
                mstore(add(add(array, _5), _2), 0)
            }
            constructor_ERC20(value, array)
            let _6 := datasize("ERC20_213_deployed")
            codecopy(0, dataoffset("ERC20_213_deployed"), _6)
            return(0, _6)
        }
        function ovm_kallio(x) -> r
        {
            let tmp_a := mload(r)
            let tmp_b := mload(0x20)
            mstore(r, "\x03\xda\xa9Y")
            mstore(4, x)
            verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", r, 0x24, r, 0x20)
            r := mload(r)
            mstore(0x00, tmp_a)
            mstore(0x20, tmp_b)
        }
        function ovm_kallio_1629() -> r
        {
            let tmp_a := mload(r)
            let tmp_b := mload(0x20)
            mstore(r, "\x03\xda\xa9Y")
            mstore(4, 0x02)
            verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", r, 0x24, r, 0x20)
            r := mload(r)
            mstore(0x00, tmp_a)
            mstore(0x20, tmp_b)
        }
        function ovm_kallio_1631() -> r
        {
            let tmp_a := mload(r)
            let tmp_b := mload(0x20)
            mstore(r, "\x03\xda\xa9Y")
            mstore(4, 0x03)
            verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", r, 0x24, r, 0x20)
            r := mload(r)
            mstore(0x00, tmp_a)
            mstore(0x20, tmp_b)
        }
        function ovm_revert()
        {
            mstore(0, "2a2a7adb")
            mstore(4, 0x20)
            mstore(36, 0)
            verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", 0, 0x64, 0, 0)
            invalid()
        }
        function ovm_sstore_1630(y)
        {
            let _1 := 0x00
            let tmp_a := mload(_1)
            let tmp_b := mload(0x20)
            let tmp_c := mload(0x40)
            mstore(_1, "\"\xbdd\xc0")
            mstore(4, 0x02)
            mstore(0x24, y)
            verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", _1, 0x44, _1, _1)
            mstore(_1, tmp_a)
            mstore(0x20, tmp_b)
            mstore(0x40, tmp_c)
        }
        function ovm_sstore_1633(y)
        {
            let _1 := 0x00
            let tmp_a := mload(_1)
            let tmp_b := mload(0x20)
            let tmp_c := mload(0x40)
            mstore(_1, "\"\xbdd\xc0")
            mstore(4, 0x03)
            mstore(0x24, y)
            verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", _1, 0x44, _1, _1)
            mstore(_1, tmp_a)
            mstore(0x20, tmp_b)
            mstore(0x40, tmp_c)
        }
        function ovm_sstore(x, y)
        {
            let _1 := 0x00
            let tmp_a := mload(_1)
            let tmp_b := mload(0x20)
            let tmp_c := mload(0x40)
            mstore(_1, "\"\xbdd\xc0")
            mstore(4, x)
            mstore(0x24, y)
            verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", _1, 0x44, _1, _1)
            mstore(_1, tmp_a)
            mstore(0x20, tmp_b)
            mstore(0x40, tmp_c)
        }
        function allocate_memory(size) -> memPtr
        {
            memPtr := mload(64)
            let newFreePtr := add(memPtr, and(add(size, 31), not(31)))
            if or(gt(newFreePtr, sub(shl(64, 1), 1)), lt(newFreePtr, memPtr)) { panic_error_0x41() }
            mstore(64, newFreePtr)
        }
        function array_dataslot_string_storage() -> data
        {
            mstore(data, 0x03)
            data := keccak256(data, 0x20)
        }
        function clear_storage_range_bytes1(start, end)
        {
            for { } lt(start, end) { start := add(start, 1) }
            {
                pop(ovm_kallio(start))
                let _1 := 0
                let tmp_a := mload(_1)
                let _2 := 0x20
                let tmp_b := mload(_2)
                let _3 := 0x40
                let tmp_c := mload(_3)
                mstore(_1, "\"\xbdd\xc0")
                mstore(4, start)
                mstore(0x24, _1)
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", _1, 0x44, _1, _1)
                mstore(_1, tmp_a)
                mstore(_2, tmp_b)
                mstore(_3, tmp_c)
            }
        }
        function constructor_ERC20(var_initialSupply, var_name_mpos)
        {
            let _1 := 0
            let tmp_a := mload(_1)
            mstore(_1, "sP\x90d")
            let _2 := 0x20
            verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", _1, 4, _1, _2)
            let r := mload(_1)
            mstore(_1, tmp_a)
            mstore(_1, and(r, sub(shl(160, 1), 1)))
            mstore(_2, _1)
            let dataSlot := keccak256(_1, 0x40)
            pop(ovm_kallio(dataSlot))
            ovm_sstore(dataSlot, var_initialSupply)
            pop(ovm_kallio_1629())
            ovm_sstore_1630(var_initialSupply)
            let newLen := mload(var_name_mpos)
            if gt(newLen, sub(shl(64, 1), 1)) { panic_error_0x41() }
            let oldLen := extract_byte_array_length(ovm_kallio_1631())
            let srcOffset := _1
            srcOffset := _2
            let dstDataArea := _1
            let _3 := gt(newLen, 31)
            let _4 := gt(oldLen, 31)
            if or(_4, _3)
            {
                dstDataArea := array_dataslot_string_storage()
            }
            if _4
            {
                let deleteStart := add(dstDataArea, shr(5, add(newLen, 31)))
                if lt(newLen, _2) { deleteStart := dstDataArea }
                clear_storage_range_bytes1(deleteStart, add(dstDataArea, shr(5, add(oldLen, 31))))
            }
            switch _3
            case 1 {
                let loopEnd := and(newLen, not(31))
                let dstPtr := dstDataArea
                let i := _1
                for { } lt(i, loopEnd) { i := add(i, _2) }
                {
                    ovm_sstore(dstPtr, mload(add(var_name_mpos, srcOffset)))
                    dstPtr := add(dstPtr, 1)
                    srcOffset := add(srcOffset, _2)
                }
                if lt(loopEnd, newLen)
                {
                    let lastValue := mload(add(var_name_mpos, srcOffset))
                    ovm_sstore(dstPtr, and(lastValue, not(shr(and(shl(0x03, newLen), 248), not(0)))))
                }
                ovm_sstore_1633(add(shl(1, newLen), 1))
            }
            default {
                let value := _1
                if newLen
                {
                    value := mload(add(var_name_mpos, srcOffset))
                }
                ovm_sstore_1633(extract_used_part_and_set_length_of_short_byte_array(value, newLen))
            }
        }
        function extract_byte_array_length(data) -> length
        {
            length := shr(1, data)
            let outOfPlaceEncoding := and(data, 1)
            if iszero(outOfPlaceEncoding) { length := and(length, 0x7f) }
            if eq(outOfPlaceEncoding, lt(length, 32))
            {
                mstore(0, shl(224, 0x4e487b71))
                mstore(4, 0x22)
                invalid()
            }
        }
        function extract_used_part_and_set_length_of_short_byte_array(data, len) -> used
        {
            used := or(and(data, not(shr(shl(3, len), not(0)))), shl(1, len))
        }
        function panic_error_0x41()
        {
            mstore(0, shl(224, 0x4e487b71))
            mstore(4, 0x41)
            invalid()
        }
    }
    object "ERC20_213_deployed" {
        code {
            {
                let _1 := 64
                mstore(_1, 128)
                if iszero(lt(calldatasize(), 4))
                {
                    switch shr(224, calldataload(0))
                    case 0x06fdde03 {
                        abi_decode(calldatasize())
                        let ret := read_from_storage_dynamic_split_string()
                        let memPos := mload(_1)
                        return(memPos, sub(abi_encode_string(memPos, ret), memPos))
                    }
                    case 0x095ea7b3 {
                        let param, param_1 := abi_decode_addresst_uint256(calldatasize())
                        let ret_1 := fun_approve(param, param_1)
                        let memPos_1 := mload(_1)
                        return(memPos_1, sub(abi_encode_bool(memPos_1, ret_1), memPos_1))
                    }
                    case 0x18160ddd {
                        abi_decode(calldatasize())
                        let _2 := ovm_kallio_5348()
                        let memPos_2 := mload(_1)
                        return(memPos_2, sub(abi_encode_uint256(memPos_2, _2), memPos_2))
                    }
                    case 0x23b872dd {
                        let param_2, param_3, param_4 := abi_decode_addresst_addresst_uint256(calldatasize())
                        let ret_2 := fun_transferFrom(param_2, param_3, param_4)
                        let memPos_3 := mload(_1)
                        return(memPos_3, sub(abi_encode_bool(memPos_3, ret_2), memPos_3))
                    }
                    case 0x27e235e3 {
                        let ret_3 := getter_fun_balances(abi_decode_ovm_address(calldatasize()))
                        let memPos_4 := mload(_1)
                        return(memPos_4, sub(abi_encode_uint256(memPos_4, ret_3), memPos_4))
                    }
                    case 0x55b6ed5c {
                        let param_5, param_6 := abi_decode_addresst_ovm_address(calldatasize())
                        let ret_4 := read_from_storage_split_dynamic_uint256(mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address(mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2085(param_5), param_6))
                        let memPos_5 := mload(_1)
                        return(memPos_5, sub(abi_encode_uint256(memPos_5, ret_4), memPos_5))
                    }
                    case 0x70a08231 {
                        let ret_5 := fun_balanceOf(abi_decode_ovm_address(calldatasize()))
                        let memPos_6 := mload(_1)
                        return(memPos_6, sub(abi_encode_uint256(memPos_6, ret_5), memPos_6))
                    }
                    case 0xa9059cbb {
                        let param_7, param_8 := abi_decode_addresst_uint256(calldatasize())
                        let ret_6 := fun_transfer(param_7, param_8)
                        let memPos_7 := mload(_1)
                        return(memPos_7, sub(abi_encode_bool(memPos_7, ret_6), memPos_7))
                    }
                    case 0xdd62ed3e {
                        let param_9, param_10 := abi_decode_addresst_ovm_address(calldatasize())
                        let value := ovm_kallio(mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address(mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2093(param_9), param_10))
                        let memPos_8 := mload(_1)
                        return(memPos_8, sub(abi_encode_uint256(memPos_8, value), memPos_8))
                    }
                }
                ovm_revert_2094()
            }
            function ovm_kallo() -> r
            {
                let tmp_a := mload(r)
                mstore(r, "sP\x90d")
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", r, 4, r, 0x20)
                r := mload(r)
                mstore(0, tmp_a)
            }
            function ovm_kallio_5348() -> r
            {
                let tmp_a := mload(r)
                let tmp_b := mload(0x20)
                mstore(r, "\x03\xda\xa9Y")
                mstore(4, 2)
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", r, 0x24, r, 0x20)
                r := mload(r)
                mstore(0x00, tmp_a)
                mstore(0x20, tmp_b)
            }
            function ovm_kallio_5351() -> r
            {
                let tmp_a := mload(r)
                let tmp_b := mload(0x20)
                mstore(r, "\x03\xda\xa9Y")
                mstore(4, 3)
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", r, 0x24, r, 0x20)
                r := mload(r)
                mstore(0x00, tmp_a)
                mstore(0x20, tmp_b)
            }
            function ovm_kallio(x) -> r
            {
                let tmp_a := mload(r)
                let tmp_b := mload(0x20)
                mstore(r, "\x03\xda\xa9Y")
                mstore(4, x)
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", r, 0x24, r, 0x20)
                r := mload(r)
                mstore(0x00, tmp_a)
                mstore(0x20, tmp_b)
            }
            function ovm_revert_2094()
            {
                mstore(0, "2a2a7adb")
                mstore(4, 0x20)
                mstore(36, 0)
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", 0, 0x64, 0, 0)
                invalid()
            }
            function ovm_revert_5349(data)
            {
                if lt(data, 0x64) { invalid() }
                let callBytes := add(data, not(99))
                mstore(callBytes, "2a2a7adb")
                mstore(add(data, not(95)), 0x20)
                mstore(add(data, not(63)), 164)
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", callBytes, 264, 0, 0)
                invalid()
            }
            function ovm_revert(data)
            {
                if lt(data, 0x64) { invalid() }
                let callBytes := add(data, not(99))
                mstore(callBytes, "2a2a7adb")
                mstore(add(data, not(95)), 0x20)
                mstore(add(data, not(63)), 132)
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", callBytes, 232, 0, 0)
                invalid()
            }
            function abi_decode(dataEnd)
            {
                if slt(add(dataEnd, not(3)), 0) { ovm_revert_2094() }
            }
            function abi_decode_ovm_address(dataEnd) -> value0
            {
                if slt(add(dataEnd, not(3)), 32) { ovm_revert_2094() }
                let value := calldataload(4)
                if iszero(eq(value, and(value, sub(shl(160, 1), 1)))) { ovm_revert_2094() }
                value0 := value
            }
            function abi_decode_addresst_ovm_address(dataEnd) -> value0, value1
            {
                if slt(add(dataEnd, not(3)), 64) { ovm_revert_2094() }
                let value := calldataload(4)
                let _1 := sub(shl(160, 1), 1)
                if iszero(eq(value, and(value, _1))) { ovm_revert_2094() }
                value0 := value
                let value_1 := calldataload(36)
                if iszero(eq(value_1, and(value_1, _1))) { ovm_revert_2094() }
                value1 := value_1
            }
            function abi_decode_addresst_addresst_uint256(dataEnd) -> value0, value1, value2
            {
                if slt(add(dataEnd, not(3)), 96) { ovm_revert_2094() }
                let value := calldataload(4)
                let _1 := sub(shl(160, 1), 1)
                if iszero(eq(value, and(value, _1))) { ovm_revert_2094() }
                value0 := value
                let value_1 := calldataload(36)
                if iszero(eq(value_1, and(value_1, _1))) { ovm_revert_2094() }
                value1 := value_1
                value2 := calldataload(68)
            }
            function abi_decode_addresst_uint256(dataEnd) -> value0, value1
            {
                if slt(add(dataEnd, not(3)), 64) { ovm_revert_2094() }
                let value := calldataload(4)
                if iszero(eq(value, and(value, sub(shl(160, 1), 1)))) { ovm_revert_2094() }
                value0 := value
                value1 := calldataload(36)
            }
            function abi_encode_bool(headStart, value0) -> tail
            {
                tail := add(headStart, 32)
                mstore(headStart, iszero(iszero(value0)))
            }
            function abi_encode_string(headStart, value0) -> tail
            {
                let _1 := 32
                mstore(headStart, _1)
                let length := mload(value0)
                mstore(add(headStart, _1), length)
                let i := tail
                for { } lt(i, length) { i := add(i, _1) }
                {
                    mstore(add(add(headStart, i), 64), mload(add(add(value0, i), _1)))
                }
                if gt(i, length)
                {
                    mstore(add(add(headStart, length), 64), tail)
                }
                tail := add(add(headStart, and(add(length, 31), not(31))), 64)
            }
            function abi_encode_uint256(headStart, value0) -> tail
            {
                tail := add(headStart, 32)
                mstore(headStart, value0)
            }
            function array_dataslot_string_storage() -> data
            {
                mstore(data, 3)
                data := keccak256(data, 0x20)
            }
            function array_storeLengthForEncoding_string(pos, length) -> updated_pos
            {
                mstore(pos, length)
                updated_pos := add(pos, 0x20)
            }
            function checked_add_uint256(x, y) -> sum
            {
                if gt(x, not(y)) { panic_error_0x11() }
                sum := add(x, y)
            }
            function checked_sub_uint256(x, y) -> diff
            {
                if lt(x, y) { panic_error_0x11() }
                diff := sub(x, y)
            }
            function finalize_allocation(memPtr, size)
            {
                let newFreePtr := add(memPtr, and(add(size, 31), not(31)))
                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr))
                {
                    mstore(0, shl(224, 0x4e487b71))
                    mstore(4, 0x41)
                    invalid()
                }
                mstore(64, newFreePtr)
            }
            function fun_approve(var_spender, var_amount) -> var
            {
                let tmp_a := mload(var)
                let _1 := "sP\x90d"
                mstore(var, _1)
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", var, 4, var, 0x20)
                let r := mload(var)
                mstore(var, tmp_a)
                mstore(var, and(r, sub(shl(160, 1), 1)))
                mstore(0x20, 0x01)
                update_storage_value_offsett_uint256_to_uint256(mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address(keccak256(var, 0x40), var_spender), var_amount)
                let tmp_a_1 := mload(var)
                mstore(var, _1)
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", var, 4, var, 0x20)
                let r_1 := mload(var)
                mstore(var, tmp_a_1)
                let _2 := mload(0x40)
                mstore(_2, var_amount)
                log3(_2, 0x20, 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925, r_1, var_spender)
                var := 0x01
            }
            function fun_balanceOf(var_owner) -> var
            {
                var := ovm_kallio(mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2111(var_owner))
            }
            function fun_transferFrom(var_from, var__to, var__amount) -> var
            {
                if lt(ovm_kallio(mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2111(var_from)), var__amount)
                {
                    let memPtr := mload(64)
                    mstore(memPtr, shl(229, 4594637))
                    mstore(add(memPtr, 4), 32)
                    mstore(add(memPtr, 36), 79)
                    mstore(add(memPtr, 68), "Can't transfer from the desired ")
                    mstore(add(memPtr, 100), "account because it doesn't have ")
                    mstore(add(memPtr, 132), "enough balance.")
                    ovm_revert_5349(memPtr)
                }
                let _1 := mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2093(var_from)
                require_helper_stringliteral_0e5b(iszero(lt(ovm_kallio(mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address(_1, ovm_kallo())), var__amount)))
                let _2 := mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2111(var__to)
                update_storage_value_offsett_uint256_to_uint256(_2, checked_add_uint256(ovm_kallio(_2), var__amount))
                let _3 := mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2111(var_from)
                update_storage_value_offsett_uint256_to_uint256(_3, checked_sub_uint256(ovm_kallio(_3), var__amount))
                let _4 := mload(64)
                log3(_4, sub(abi_encode_uint256(_4, var__amount), _4), 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef, var_from, var__to)
                var := 0x01
            }
            function fun_transfer(var_to, var_amount) -> var_
            {
                let tmp_a := mload(var_)
                mstore(var_, "sP\x90d")
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", var_, 4, var_, 0x20)
                let r := mload(var_)
                mstore(var_, tmp_a)
                if lt(ovm_kallio(mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2111(r)), var_amount)
                {
                    let memPtr := mload(64)
                    mstore(memPtr, shl(229, 4594637))
                    mstore(add(memPtr, 4), 0x20)
                    mstore(add(memPtr, 36), 52)
                    mstore(add(memPtr, 68), "You don't have enough balance to")
                    mstore(add(memPtr, 100), " make this transfer!")
                    ovm_revert(memPtr)
                }
                let _1 := mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2111(ovm_kallo())
                update_storage_value_offsett_uint256_to_uint256(_1, checked_sub_uint256(ovm_kallio(_1), var_amount))
                let _2 := mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2111(var_to)
                update_storage_value_offsett_uint256_to_uint256(_2, checked_add_uint256(ovm_kallio(_2), var_amount))
                let expr := ovm_kallo()
                let _3 := mload(64)
                log3(_3, sub(abi_encode_uint256(_3, var_amount), _3), 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef, expr, var_to)
                var_ := 0x01
            }
            function getter_fun_balances(key) -> ret
            {
                ret := shr(shl(3, ret), ovm_kallio(mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2111(key)))
            }
            function mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2085(key) -> dataSlot
            {
                mstore(dataSlot, and(key, sub(shl(160, 1), 1)))
                mstore(0x20, 1)
                dataSlot := keccak256(dataSlot, 0x40)
            }
            function mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2093(key) -> dataSlot
            {
                mstore(dataSlot, and(key, sub(shl(160, 1), 1)))
                mstore(0x20, 0x01)
                dataSlot := keccak256(dataSlot, 0x40)
            }
            function mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address_2111(key) -> dataSlot
            {
                mstore(dataSlot, and(key, sub(shl(160, 1), 1)))
                mstore(0x20, dataSlot)
                dataSlot := keccak256(dataSlot, 0x40)
            }
            function mapping_index_access_mapping_address_mapping_address_uint256_of_ovm_address(slot, key) -> dataSlot
            {
                mstore(dataSlot, and(key, sub(shl(160, 1), 1)))
                mstore(0x20, slot)
                dataSlot := keccak256(dataSlot, 0x40)
            }
            function panic_error_0x11()
            {
                mstore(0, shl(224, 0x4e487b71))
                mstore(4, 0x11)
                invalid()
            }
            function read_from_storage_dynamic_split_string() -> value
            {
                if iszero(iszero(value))
                {
                    mstore(value, shl(224, 0x4e487b71))
                    mstore(4, value)
                    invalid()
                }
                let memPtr := mload(64)
                let ret := value
                let slotValue := ovm_kallio_5351()
                let length := value
                let _1 := 1
                length := shr(_1, slotValue)
                let outOfPlaceEncoding := and(slotValue, _1)
                if iszero(outOfPlaceEncoding) { length := and(length, 0x7f) }
                let _2 := 32
                if eq(outOfPlaceEncoding, lt(length, _2))
                {
                    mstore(value, shl(224, 0x4e487b71))
                    mstore(4, 0x22)
                    invalid()
                }
                let pos := array_storeLengthForEncoding_string(memPtr, length)
                switch outOfPlaceEncoding
                case 0 {
                    mstore(pos, and(slotValue, not(255)))
                    ret := add(pos, _2)
                }
                case 1 {
                    let dataPos := array_dataslot_string_storage()
                    let i := value
                    for { } lt(i, length) { i := add(i, _2) }
                    {
                        mstore(add(pos, i), ovm_kallio(dataPos))
                        dataPos := add(dataPos, _1)
                    }
                    ret := add(pos, i)
                }
                finalize_allocation(memPtr, sub(ret, memPtr))
                value := memPtr
            }
            function read_from_storage_split_dynamic_uint256(slot) -> value
            {
                value := shr(shl(3, value), ovm_kallio(slot))
            }
            function require_helper_stringliteral_0e5b(condition)
            {
                if iszero(condition)
                {
                    let memPtr := mload(64)
                    mstore(memPtr, shl(229, 4594637))
                    mstore(add(memPtr, 4), 32)
                    mstore(add(memPtr, 36), 86)
                    mstore(add(memPtr, 68), "Can't transfer from the desired ")
                    mstore(add(memPtr, 100), "account because you don't have e")
                    mstore(add(memPtr, 132), "nough of an allowance.")
                    ovm_revert_5349(memPtr)
                }
            }
            function update_storage_value_offsett_uint256_to_uint256(slot, value)
            {
                pop(ovm_kallio(slot))
                let _1 := 0
                let tmp_a := mload(_1)
                let tmp_b := mload(0x20)
                let tmp_c := mload(0x40)
                mstore(_1, "\"\xbdd\xc0")
                mstore(4, slot)
                mstore(0x24, value)
                verbatim_4i_0o("3`\x00\x90Z\xf1X`\x0e\x01W=`\x00\x80>=`\x00\xfd[=`\x01\x14\x15X`\n\x01W`\x01`\x00\xf3[", _1, 0x44, _1, _1)
                mstore(_1, tmp_a)
                mstore(0x20, tmp_b)
                mstore(0x40, tmp_c)
            }
        }
    }
}


Binary representation:
6080604052620015ad80380362000016816200041e565b8183823981810192506040818403121562000036576200003562000266565b5b805191506020808201516001600160401b03808211156200005c576200005b62000266565b5b818401935085601f850112151562000079576200007862000266565b5b83519150808211156200009157620000906200073b565b5b50620000a682601f19601f840116016200041e565b8181528583838601011115620000c157620000c062000266565b5b600095505b81861015620000e7578286850101518387830101525b8286019550620000c6565b81861115620000f95760008383830101525b62000105818662000501565b505050505050610e5c8062000751600039806000f3506200074f565b600080516020517f03daa95900000000000000000000000000000000000000000000000000000000835283600452602083602485336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b82519250816000528060205250505b919050565b600080516020517f03daa9590000000000000000000000000000000000000000000000000000000083526002600452602083602485336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b82519250816000528060205250505b90565b600080516020517f03daa9590000000000000000000000000000000000000000000000000000000083526003600452602083602485336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b82519250816000528060205250505b90565b7f3261326137616462000000000000000000000000000000000000000000000000600052602060045260006024526000600060646000336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35bfe5b565b600080516020516040517f22bd64c00000000000000000000000000000000000000000000000000000000084526002600452846024528384604486336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b828452816020528060405250505050505b565b600080516020516040517f22bd64c00000000000000000000000000000000000000000000000000000000084526003600452846024528384604486336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b828452816020528060405250505050505b565b600080516020516040517f22bd64c000000000000000000000000000000000000000000000000000000000845284600452856024528384604486336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b82845281602052806040525050505050505b565b60006040519050601f19601f83011681018181106001600160401b03821117156200044e576200044d6200073b565b5b80604052505b919050565b6000600381526020812090505b90565b5b81811015620004fc576200047e8162000121565b506000805160208051604080517f22bd64c000000000000000000000000000000000000000000000000000000000865286600452856024528586604488336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b8486528284528082525050505050505b6001810190506200046a565b50505b565b600080517f7350906400000000000000000000000000000000000000000000000000000000825260208083600485336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b82518284526001600160a01b0381168452508281526040832091506200057a8262000121565b50620005878483620003ab565b620005916200018e565b506200059d84620002c5565b845191506001600160401b03821115620005bc57620005bb6200073b565b5b620005d0620005ca620001fa565b620006e0565b8382905084601f8511601f841181811715620005f357620005f062000459565b92505b80156200062657601f870160051c83018688101562000610578390505b62000624601f870160051c85018262000469565b505b5080600181146200065e5787945086156200064257838a015194505b6200065862000652888762000720565b62000338565b620006d3565b601f198716945082885b86811015620006975762000680868d015183620003ab565b60018201915087860195505b878101905062000668565b5087861015620006c057848b0151620006be60001960f88b60031b161c19821683620003ab565b505b50620006d260018860011b0162000338565b5b505050505050505050505b565b60008160011c905060018216801515620006fb57607f821691505b602082108114156200071957634e487b7160e01b6000526022600452fe5b505b919050565b60008260011b6000198460031b1c1983161790505b92915050565b634e487b7160e01b6000526041600452fe5b565bfe60406080815260043610151561021e5760003560e01c6306fdde03811461007d5763095ea7b381146100a5576318160ddd81146100d2576323b872dd81146100fa576327e235e38114610129576355b6ed5c8114610151576370a08231811461018e5763a9059cbb81146101b65763dd62ed3e81146101e35761021c565b6100863661051a565b61008e610c44565b82518061009b8383610698565b0381f3505061021c565b6100ae3661063d565b6100b8818361079f565b9150508251806100c88383610684565b0381f3505061021c565b6100db3661051a565b6100e361028b565b8251806100f083836106f2565b0381f3505061021c565b610103366105d4565b61010e8183856108ae565b9250505082518061011f8383610684565b0381f3505061021c565b61013a61013536610534565b610b95565b82518061014783836106f2565b0381f3505061021c565b61015a36610574565b61017461016f8261016a85610bb5565b610c11565b610d24565b91505082518061018483836106f2565b0381f3505061021c565b61019f61019a36610534565b610893565b8251806101ac83836106f2565b0381f3505061021c565b6101bf3661063d565b6101c98183610a18565b9150508251806101d98383610684565b0381f3505061021c565b6101ec36610574565b610206610201826101fc85610bd4565b610c11565b610363565b91505082518061021683836106f2565b0381f350505b505b506102276103d0565b610e5b565b600080517f73509064000000000000000000000000000000000000000000000000000000008252602082600484336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b8151915080600052505b90565b600080516020517f03daa9590000000000000000000000000000000000000000000000000000000083526002600452602083602485336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b82519250816000528060205250505b90565b600080516020517f03daa9590000000000000000000000000000000000000000000000000000000083526003600452602083602485336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b82519250816000528060205250505b90565b600080516020517f03daa95900000000000000000000000000000000000000000000000000000000835283600452602083602485336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b82519250816000528060205250505b919050565b7f3261326137616462000000000000000000000000000000000000000000000000600052602060045260006024526000600060646000336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35bfe5b565b606481101561043a57fe5b60631981017f326132613761646200000000000000000000000000000000000000000000000081526020605f1983015260a4603f198301526000600061010883336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b50fe505b565b60648110156104b057fe5b60631981017f326132613761646200000000000000000000000000000000000000000000000081526020605f198301526084603f198301526000600060e883336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b50fe505b565b6000600319820112156105305761052f6103d0565b5b505b565b600060206003198301121561054c5761054b6103d0565b5b6004356001600160a01b0381168114151561056a576105696103d0565b5b809150505b919050565b6000600060406003198401121561058e5761058d6103d0565b5b6004356001600160a01b03808216821415156105ad576105ac6103d0565b5b8193506024359150808216821415156105c9576105c86103d0565b5b50809150505b915091565b6000600060006060600319850112156105f0576105ef6103d0565b5b6004356001600160a01b038082168214151561060f5761060e6103d0565b5b81945060243591508082168214151561062b5761062a6103d0565b5b508092505060443590505b9193909250565b60006000604060031984011215610657576106566103d0565b5b6004356001600160a01b03811681141515610675576106746103d0565b5b8092505060243590505b915091565b600060208201905082151582525b92915050565b6000602080835283518082850152825b818110156106c857828187010151604082870101525b82810190506106a8565b818111156106d95783604083870101525b506040601f19601f830116850101925050505b92915050565b60006020820190508282525b92915050565b6000600381526020812090505b90565b81815260006020820190505b92915050565b6000821982111561073a57610739610c30565b5b82820190505b92915050565b60008282101561075957610758610c30565b5b82820390505b92915050565b601f19601f830116810181811067ffffffffffffffff8211171561079557634e487b7160e01b6000526041600452fe5b806040525050505b565b600080517f7350906400000000000000000000000000000000000000000000000000000000808352602083600485336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b82518284526001600160a01b038116845250600160205261081f8561081a8660408720610c11565b610dde565b8251915080835250602082600484336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b8151818352604051915084825283817f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925602085a35050600190505b92915050565b60006108a66108a183610bf3565b610363565b90505b919050565b6000836108c26108bd84610bf3565b610363565b101561095f5760405162461bcd60e51b815260206004820152604f60248201527f43616e2774207472616e736665722066726f6d2074686520646573697265642060448201527f6163636f756e74206265636175736520697420646f65736e277420686176652060648201527f656e6f7567682062616c616e63652e0000000000000000000000000000000000608482015261095d8161042f565b505b61096882610bd4565b61098c8561098561098061097a61022c565b85610c11565b610363565b1015610d3c565b5061099683610bf3565b6109b16109ab866109a684610363565b610726565b82610dde565b506109bb82610bf3565b6109d66109d0866109cb84610363565b610746565b82610dde565b5060405183837fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83610a0889866106f2565b0384a350600190505b9392505050565b600080517f73509064000000000000000000000000000000000000000000000000000000008252602082600484336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b815181835284610a81610a7c83610bf3565b610363565b1015610af957604051915062461bcd60e51b825260206004830152603460248301527f596f7520646f6e2774206861766520656e6f7567682062616c616e636520746f60448301527f206d616b652074686973207472616e73666572210000000000000000000000006064830152610af8826104a5565b5b5050610b0b610b0661022c565b610bf3565b610b26610b2085610b1b84610363565b610746565b82610dde565b50610b3082610bf3565b610b4b610b4585610b4084610363565b610726565b82610dde565b50610b5461022c565b60405183827fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83610b8589866106f2565b0384a35050600190505b92915050565b6000610ba8610ba383610bf3565b610363565b8160031b1c90505b919050565b60006001600160a01b038216815260016020526040812090505b919050565b60006001600160a01b038216815260016020526040812090505b919050565b60006001600160a01b0382168152806020526040812090505b919050565b60006001600160a01b0383168152816020526040812090505b92915050565b634e487b7160e01b6000526011600452fe5b565b600080151515610c5e57634e487b7160e01b815280600452fe5b60405181610c6a6102f7565b83600182811c9150808316801515610c8357607f831692505b6020808410821415610ca057634e487b7160e01b88526022600452fe5b610caa8488610714565b8260008114610cc05760018114610cd157610d08565b60ff19871682528282019750610d08565b610cd9610704565b8a5b87811015610d0057610cec82610363565b8185015286820191505b8481019050610cdb565b808401995050505b50505050505050610d1b82820383610765565b50809150505b90565b6000610d2f82610363565b8160031b1c90505b919050565b801515610dda5760405162461bcd60e51b815260206004820152605660248201527f43616e2774207472616e736665722066726f6d2074686520646573697265642060448201527f6163636f756e74206265636175736520796f7520646f6e27742068617665206560648201527f6e6f756768206f6620616e20616c6c6f77616e63652e000000000000000000006084820152610dd88161042f565b505b505b565b610de781610363565b50600080516020516040517f22bd64c000000000000000000000000000000000000000000000000000000000845284600452856024528384604486336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b82845281602052806040525050505050505b565b

Text representation:
    /* "<stdin>":6297:6300   */
  0x80
    /* "<stdin>":6293:6295   */
  0x40
    /* "<stdin>":6286:6301   */
  mstore
  bytecodeSize
    /* "<stdin>":11124:11135   */
  dup1
    /* "<stdin>":11112:11122   */
  codesize
    /* "<stdin>":11108:11136   */
  sub
    /* "<stdin>":11174:11198   */
  tag_1
    /* "<stdin>":11190:11197   */
  dup2
    /* "<stdin>":11174:11198   */
  tag_2
  jump	// in
tag_1:
    /* "<stdin>":11251:11258   */
  dup2
    /* "<stdin>":11238:11249   */
  dup4
    /* "<stdin>":11220:11236   */
  dup3
    /* "<stdin>":11211:11259   */
  codecopy
    /* "<stdin>":11398:11405   */
  dup2
    /* "<stdin>":11380:11396   */
  dup2
    /* "<stdin>":11376:11406   */
  add
  swap3
  pop
    /* "<stdin>":6293:6295   */
  0x40
    /* "<stdin>":7642:7651   */
  dup2
    /* "<stdin>":7633:7640   */
  dup5
    /* "<stdin>":7629:7652   */
  sub
    /* "<stdin>":7625:7657   */
  slt
    /* "<stdin>":7622:7624   */
  iszero
  tag_3
  jumpi
    /* "<stdin>":7660:7676   */
  tag_4
  tag_5
  jump	// in
tag_4:
    /* "<stdin>":7622:7624   */
tag_3:
    /* "<stdin>":7431:7437   */
  dup1
    /* "<stdin>":7425:7438   */
  mload
    /* "<stdin>":7416:7438   */
  swap2
  pop
    /* "<stdin>":7900:7902   */
  0x20
  dup1
    /* "<stdin>":7889:7898   */
  dup3
    /* "<stdin>":7885:7903   */
  add
    /* "<stdin>":7879:7904   */
  mload
    /* "<stdin>":7935:7953   */
  sub(shl(0x40, 0x01), 0x01)
  dup1
    /* "<stdin>":7927:7933   */
  dup3
    /* "<stdin>":7924:7954   */
  gt
    /* "<stdin>":7921:7923   */
  iszero
  tag_6
  jumpi
    /* "<stdin>":7957:7973   */
  tag_7
  tag_5
  jump	// in
tag_7:
    /* "<stdin>":7921:7923   */
tag_6:
    /* "<stdin>":8060:8066   */
  dup2
    /* "<stdin>":8049:8058   */
  dup5
    /* "<stdin>":8045:8067   */
  add
  swap4
  pop
    /* "<stdin>":7141:7144   */
  dup6
    /* "<stdin>":7134:7138   */
  0x1f
    /* "<stdin>":7126:7132   */
  dup6
    /* "<stdin>":7122:7139   */
  add
    /* "<stdin>":7118:7145   */
  slt
    /* "<stdin>":7111:7146   */
  iszero
    /* "<stdin>":7108:7110   */
  iszero
  tag_8
  jumpi
    /* "<stdin>":7149:7165   */
  tag_9
  tag_5
  jump	// in
tag_9:
    /* "<stdin>":7108:7110   */
tag_8:
    /* "<stdin>":7200:7206   */
  dup4
    /* "<stdin>":7194:7207   */
  mload
  swap2
  pop
    /* "<stdin>":7935:7953   */
  dup1
    /* "<stdin>":8508:8514   */
  dup3
    /* "<stdin>":8505:8535   */
  gt
    /* "<stdin>":8502:8504   */
  iszero
  tag_10
  jumpi
    /* "<stdin>":8538:8556   */
  tag_11
  tag_12
  jump	// in
tag_11:
    /* "<stdin>":8502:8504   */
tag_10:
  pop
    /* "<stdin>":6729:6795   */
  tag_13
    /* "<stdin>":7900:7902   */
  dup3
    /* "<stdin>":16014:16021   */
  not(0x1f)
    /* "<stdin>":7134:7138   */
  0x1f
    /* "<stdin>":8602:8608   */
  dup5
    /* "<stdin>":15998:16012   */
  add
    /* "<stdin>":15994:16022   */
  and
    /* "<stdin>":8662:8677   */
  add
    /* "<stdin>":6729:6795   */
  tag_2
  jump	// in
tag_13:
    /* "<stdin>":6822:6828   */
  dup2
    /* "<stdin>":6815:6820   */
  dup2
    /* "<stdin>":6808:6829   */
  mstore
    /* "<stdin>":6906:6909   */
  dup6
    /* "<stdin>":7900:7902   */
  dup4
    /* "<stdin>":6897:6903   */
  dup4
    /* "<stdin>":7292:7298   */
  dup7
    /* "<stdin>":6888:6904   */
  add
  add
    /* "<stdin>":6885:6910   */
  gt
    /* "<stdin>":6882:6884   */
  iszero
  tag_14
  jumpi
    /* "<stdin>":6913:6929   */
  tag_15
  tag_5
  jump	// in
tag_15:
    /* "<stdin>":6882:6884   */
tag_14:
  0x00
    /* "<stdin>":13446:13456   */
  swap6
  pop
    /* "<stdin>":13469:13594   */
tag_16:
    /* "<stdin>":13483:13489   */
  dup2
    /* "<stdin>":13480:13481   */
  dup7
    /* "<stdin>":13477:13490   */
  lt
    /* "<stdin>":13469:13594   */
  iszero
  tag_18
  jumpi
    /* "<stdin>":7900:7902   */
  dup3
    /* "<stdin>":13576:13577   */
  dup7
    /* "<stdin>":7292:7298   */
  dup6
    /* "<stdin>":13567:13578   */
  add
  add
    /* "<stdin>":13561:13579   */
  mload
    /* "<stdin>":7900:7902   */
  dup4
    /* "<stdin>":13557:13558   */
  dup8
    /* "<stdin>":6857:6862   */
  dup4
    /* "<stdin>":13548:13559   */
  add
  add
    /* "<stdin>":13541:13580   */
  mstore
    /* "<stdin>":13469:13594   */
tag_17:
    /* "<stdin>":7900:7902   */
  dup3
    /* "<stdin>":13502:13503   */
  dup7
    /* "<stdin>":13498:13508   */
  add
    /* "<stdin>":13493:13508   */
  swap6
  pop
    /* "<stdin>":13469:13594   */
  jump(tag_16)
tag_18:
    /* "<stdin>":13616:13622   */
  dup2
    /* "<stdin>":13613:13614   */
  dup7
    /* "<stdin>":13610:13623   */
  gt
    /* "<stdin>":13607:13609   */
  iszero
  tag_19
  jumpi
  0x00
    /* "<stdin>":7900:7902   */
  dup4
    /* "<stdin>":13699:13705   */
  dup4
    /* "<stdin>":6857:6862   */
  dup4
    /* "<stdin>":13690:13706   */
  add
  add
    /* "<stdin>":13683:13710   */
  mstore
    /* "<stdin>":13607:13609   */
tag_19:
    /* "<stdin>":6434:6463   */
  tag_20
    /* "<stdin>":6460:6462   */
  dup2
    /* "<stdin>":6456:6458   */
  dup7
    /* "<stdin>":6434:6463   */
  tag_21
  jump	// in
tag_20:
  pop
  pop
  pop
  pop
  pop
  pop
  dataSize(sub_0)
    /* "<stdin>":6519:6549   */
  dup1
  dataOffset(sub_0)
  0x00
    /* "<stdin>":6473:6550   */
  codecopy
    /* "<stdin>":6570:6600   */
  dup1
  0x00
    /* "<stdin>":6560:6601   */
  return
  pop
    /* "<stdin>":1674:1924   */
  jump(tag_22)
tag_23:
    /* "<stdin>":1715:1716   */
  0x00
  dup1
    /* "<stdin>":1736:1747   */
  mload
    /* "<stdin>":1771:1775   */
  0x20
    /* "<stdin>":1765:1776   */
  mload
    /* "<stdin>":6117:6130   */
  0x03daa95900000000000000000000000000000000000000000000000000000000
  dup4
    /* "<stdin>":1781:1801   */
  mstore
    /* "<stdin>":1816:1817   */
  dup4
    /* "<stdin>":1813:1814   */
  0x04
    /* "<stdin>":1806:1818   */
  mstore
    /* "<stdin>":1771:1775   */
  0x20
  dup4
    /* "<stdin>":1842:1846   */
  0x24
  dup6
  verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
  dup3
    /* "<stdin>":1866:1874   */
  mload
    /* "<stdin>":1861:1874   */
  swap3
  pop
    /* "<stdin>":1892:1897   */
  dup2
    /* "<stdin>":1886:1890   */
  0x00
    /* "<stdin>":1879:1898   */
  mstore
    /* "<stdin>":1916:1921   */
  dup1
    /* "<stdin>":1771:1775   */
  0x20
    /* "<stdin>":1903:1922   */
  mstore
  pop
  pop
    /* "<stdin>":1717:1924   */
tag_24:
  swap2
  swap1
  pop
  jump	// out
    /* "<stdin>":1674:1924   */
tag_25:
    /* "<stdin>":1715:1716   */
  0x00
  dup1
    /* "<stdin>":1736:1747   */
  mload
    /* "<stdin>":1771:1775   */
  0x20
    /* "<stdin>":1765:1776   */
  mload
    /* "<stdin>":6117:6130   */
  0x03daa95900000000000000000000000000000000000000000000000000000000
  dup4
    /* "<stdin>":1781:1801   */
  mstore
    /* "<stdin>":10046:10050   */
  0x02
    /* "<stdin>":1813:1814   */
  0x04
    /* "<stdin>":1806:1818   */
  mstore
    /* "<stdin>":1771:1775   */
  0x20
  dup4
    /* "<stdin>":1842:1846   */
  0x24
  dup6
  verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
  dup3
    /* "<stdin>":1866:1874   */
  mload
    /* "<stdin>":1861:1874   */
  swap3
  pop
    /* "<stdin>":1892:1897   */
  dup2
    /* "<stdin>":1886:1890   */
  0x00
    /* "<stdin>":1879:1898   */
  mstore
    /* "<stdin>":1916:1921   */
  dup1
    /* "<stdin>":1771:1775   */
  0x20
    /* "<stdin>":1903:1922   */
  mstore
  pop
  pop
    /* "<stdin>":1717:1924   */
tag_26:
  swap1
  jump	// out
    /* "<stdin>":1674:1924   */
tag_27:
    /* "<stdin>":1715:1716   */
  0x00
  dup1
    /* "<stdin>":1736:1747   */
  mload
    /* "<stdin>":1771:1775   */
  0x20
    /* "<stdin>":1765:1776   */
  mload
    /* "<stdin>":6117:6130   */
  0x03daa95900000000000000000000000000000000000000000000000000000000
  dup4
    /* "<stdin>":1781:1801   */
  mstore
    /* "<stdin>":10262:10266   */
  0x03
    /* "<stdin>":1813:1814   */
  0x04
    /* "<stdin>":1806:1818   */
  mstore
    /* "<stdin>":1771:1775   */
  0x20
  dup4
    /* "<stdin>":1842:1846   */
  0x24
  dup6
  verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
  dup3
    /* "<stdin>":1866:1874   */
  mload
    /* "<stdin>":1861:1874   */
  swap3
  pop
    /* "<stdin>":1892:1897   */
  dup2
    /* "<stdin>":1886:1890   */
  0x00
    /* "<stdin>":1879:1898   */
  mstore
    /* "<stdin>":1916:1921   */
  dup1
    /* "<stdin>":1771:1775   */
  0x20
    /* "<stdin>":1903:1922   */
  mstore
  pop
  pop
    /* "<stdin>":1717:1924   */
tag_28:
  swap1
  jump	// out
    /* "<stdin>":5339:6062   */
tag_5:
    /* "<stdin>":5514:5524   */
  0x3261326137616462000000000000000000000000000000000000000000000000
    /* "<stdin>":5695:5715   */
  0x00
    /* "<stdin>":5824:5860   */
  mstore
    /* "<stdin>":5894:5898   */
  0x20
    /* "<stdin>":5872:5892   */
  0x04
    /* "<stdin>":5865:5899   */
  mstore
    /* "<stdin>":5695:5715   */
  0x00
    /* "<stdin>":5911:5931   */
  0x24
    /* "<stdin>":5904:5940   */
  mstore
    /* "<stdin>":5695:5715   */
  0x00
  0x00
    /* "<stdin>":5397:5401   */
  0x64
    /* "<stdin>":5695:5715   */
  0x00
  verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
    /* "<stdin>":6051:6060   */
  invalid
    /* "<stdin>":5373:6062   */
tag_29:
  jump	// out
    /* "<stdin>":6138:6204   */
tag_30:
    /* "<stdin>":968:972   */
  0x00
  dup1
    /* "<stdin>":962:973   */
  mload
    /* "<stdin>":997:1001   */
  0x20
    /* "<stdin>":991:1002   */
  mload
    /* "<stdin>":1026:1030   */
  0x40
    /* "<stdin>":1020:1031   */
  mload
    /* "<stdin>":6182:6195   */
  0x22bd64c000000000000000000000000000000000000000000000000000000000
    /* "<stdin>":968:972   */
  dup5
    /* "<stdin>":1036:1056   */
  mstore
    /* "<stdin>":10046:10050   */
  0x02
    /* "<stdin>":1068:1069   */
  0x04
    /* "<stdin>":1061:1073   */
  mstore
    /* "<stdin>":1091:1092   */
  dup5
    /* "<stdin>":1085:1089   */
  0x24
    /* "<stdin>":1078:1093   */
  mstore
    /* "<stdin>":968:972   */
  dup4
  dup5
    /* "<stdin>":1117:1121   */
  0x44
    /* "<stdin>":968:972   */
  dup7
  verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
    /* "<stdin>":1146:1151   */
  dup3
    /* "<stdin>":968:972   */
  dup5
    /* "<stdin>":1133:1152   */
  mstore
    /* "<stdin>":1170:1175   */
  dup2
    /* "<stdin>":997:1001   */
  0x20
    /* "<stdin>":1157:1176   */
  mstore
    /* "<stdin>":1194:1199   */
  dup1
    /* "<stdin>":1026:1030   */
  0x40
    /* "<stdin>":1181:1200   */
  mstore
  pop
  pop
  pop
  pop
    /* "<stdin>":6164:6204   */
  pop
tag_31:
  jump	// out
    /* "<stdin>":6138:6204   */
tag_32:
    /* "<stdin>":968:972   */
  0x00
  dup1
    /* "<stdin>":962:973   */
  mload
    /* "<stdin>":997:1001   */
  0x20
    /* "<stdin>":991:1002   */
  mload
    /* "<stdin>":1026:1030   */
  0x40
    /* "<stdin>":1020:1031   */
  mload
    /* "<stdin>":6182:6195   */
  0x22bd64c000000000000000000000000000000000000000000000000000000000
    /* "<stdin>":968:972   */
  dup5
    /* "<stdin>":1036:1056   */
  mstore
    /* "<stdin>":10262:10266   */
  0x03
    /* "<stdin>":1068:1069   */
  0x04
    /* "<stdin>":1061:1073   */
  mstore
    /* "<stdin>":1091:1092   */
  dup5
    /* "<stdin>":1085:1089   */
  0x24
    /* "<stdin>":1078:1093   */
  mstore
    /* "<stdin>":968:972   */
  dup4
  dup5
    /* "<stdin>":1117:1121   */
  0x44
    /* "<stdin>":968:972   */
  dup7
  verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
    /* "<stdin>":1146:1151   */
  dup3
    /* "<stdin>":968:972   */
  dup5
    /* "<stdin>":1133:1152   */
  mstore
    /* "<stdin>":1170:1175   */
  dup2
    /* "<stdin>":997:1001   */
  0x20
    /* "<stdin>":1157:1176   */
  mstore
    /* "<stdin>":1194:1199   */
  dup1
    /* "<stdin>":1026:1030   */
  0x40
    /* "<stdin>":1181:1200   */
  mstore
  pop
  pop
  pop
  pop
    /* "<stdin>":6164:6204   */
  pop
tag_33:
  jump	// out
    /* "<stdin>":6138:6204   */
tag_34:
    /* "<stdin>":968:972   */
  0x00
  dup1
    /* "<stdin>":962:973   */
  mload
    /* "<stdin>":997:1001   */
  0x20
    /* "<stdin>":991:1002   */
  mload
    /* "<stdin>":1026:1030   */
  0x40
    /* "<stdin>":1020:1031   */
  mload
    /* "<stdin>":6182:6195   */
  0x22bd64c000000000000000000000000000000000000000000000000000000000
    /* "<stdin>":968:972   */
  dup5
    /* "<stdin>":1036:1056   */
  mstore
    /* "<stdin>":1071:1072   */
  dup5
    /* "<stdin>":1068:1069   */
  0x04
    /* "<stdin>":1061:1073   */
  mstore
    /* "<stdin>":1091:1092   */
  dup6
    /* "<stdin>":1085:1089   */
  0x24
    /* "<stdin>":1078:1093   */
  mstore
    /* "<stdin>":968:972   */
  dup4
  dup5
    /* "<stdin>":1117:1121   */
  0x44
    /* "<stdin>":968:972   */
  dup7
  verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
    /* "<stdin>":1146:1151   */
  dup3
    /* "<stdin>":968:972   */
  dup5
    /* "<stdin>":1133:1152   */
  mstore
    /* "<stdin>":1170:1175   */
  dup2
    /* "<stdin>":997:1001   */
  0x20
    /* "<stdin>":1157:1176   */
  mstore
    /* "<stdin>":1194:1199   */
  dup1
    /* "<stdin>":1026:1030   */
  0x40
    /* "<stdin>":1181:1200   */
  mstore
  pop
  pop
  pop
  pop
    /* "<stdin>":6164:6204   */
  pop
  pop
tag_35:
  jump	// out
    /* "<stdin>":8112:8253   */
tag_2:
    /* "<stdin>":8146:8152   */
  0x00
    /* "<stdin>":8333:8335   */
  0x40
    /* "<stdin>":8327:8336   */
  mload
    /* "<stdin>":8167:8197   */
  swap1
  pop
    /* "<stdin>":16014:16021   */
  not(0x1f)
    /* "<stdin>":16018:16020   */
  0x1f
    /* "<stdin>":14543:14547   */
  dup4
    /* "<stdin>":15998:16012   */
  add
    /* "<stdin>":15994:16022   */
  and
    /* "<stdin>":14513:14519   */
  dup2
    /* "<stdin>":14509:14549   */
  add
    /* "<stdin>":14659:14665   */
  dup2
    /* "<stdin>":14647:14657   */
  dup2
    /* "<stdin>":14644:14666   */
  lt
    /* "<stdin>":7935:7953   */
  sub(shl(0x40, 0x01), 0x01)
    /* "<stdin>":14611:14621   */
  dup3
    /* "<stdin>":14608:14642   */
  gt
    /* "<stdin>":14605:14667   */
  or
    /* "<stdin>":14602:14604   */
  iszero
  tag_37
  jumpi
    /* "<stdin>":14670:14688   */
  tag_38
  tag_12
  jump	// in
tag_38:
    /* "<stdin>":14602:14604   */
tag_37:
    /* "<stdin>":14714:14724   */
  dup1
    /* "<stdin>":8333:8335   */
  0x40
    /* "<stdin>":14703:14725   */
  mstore
  pop
    /* "<stdin>":8153:8253   */
tag_36:
  swap2
  swap1
  pop
  jump	// out
    /* "<stdin>":8698:8855   */
tag_39:
    /* "<stdin>":8747:8751   */
  0x00
    /* "<stdin>":10262:10266   */
  0x03
  dup2
    /* "<stdin>":8791:8805   */
  mstore
    /* "<stdin>":8839:8843   */
  0x20
  dup2
    /* "<stdin>":8826:8844   */
  keccak256
    /* "<stdin>":8818:8844   */
  swap1
  pop
    /* "<stdin>":8752:8855   */
tag_40:
  swap1
  jump	// out
    /* "<stdin>":9221:9427   */
tag_41:
    /* "<stdin>":9285:9417   */
tag_43:
    /* "<stdin>":9302:9305   */
  dup2
    /* "<stdin>":9295:9300   */
  dup2
    /* "<stdin>":9292:9306   */
  lt
    /* "<stdin>":9285:9417   */
  iszero
  tag_45
  jumpi
    /* "<stdin>":6102:6134   */
  tag_46
    /* "<stdin>":18109:18113   */
  dup2
    /* "<stdin>":6102:6134   */
  tag_23
  jump	// in
tag_46:
  pop
    /* "<stdin>":17332:17362   */
  0x00
  dup1
    /* "<stdin>":962:973   */
  mload
    /* "<stdin>":997:1001   */
  0x20
  dup1
    /* "<stdin>":991:1002   */
  mload
    /* "<stdin>":1026:1030   */
  0x40
  dup1
    /* "<stdin>":1020:1031   */
  mload
    /* "<stdin>":6182:6195   */
  0x22bd64c000000000000000000000000000000000000000000000000000000000
    /* "<stdin>":17332:17362   */
  dup7
    /* "<stdin>":1036:1056   */
  mstore
    /* "<stdin>":1071:1072   */
  dup7
    /* "<stdin>":1068:1069   */
  0x04
    /* "<stdin>":1061:1073   */
  mstore
    /* "<stdin>":17332:17362   */
  dup6
    /* "<stdin>":1085:1089   */
  0x24
    /* "<stdin>":1078:1093   */
  mstore
    /* "<stdin>":17332:17362   */
  dup6
  dup7
    /* "<stdin>":1117:1121   */
  0x44
    /* "<stdin>":17332:17362   */
  dup9
  verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
    /* "<stdin>":1146:1151   */
  dup5
    /* "<stdin>":17332:17362   */
  dup7
    /* "<stdin>":1133:1152   */
  mstore
    /* "<stdin>":1170:1175   */
  dup3
    /* "<stdin>":997:1001   */
  dup5
    /* "<stdin>":1157:1176   */
  mstore
    /* "<stdin>":1194:1199   */
  dup1
    /* "<stdin>":1026:1030   */
  dup3
    /* "<stdin>":1181:1200   */
  mstore
  pop
  pop
  pop
  pop
  pop
  pop
    /* "<stdin>":9285:9417   */
tag_44:
    /* "<stdin>":9329:9330   */
  0x01
    /* "<stdin>":9322:9327   */
  dup2
    /* "<stdin>":9318:9331   */
  add
    /* "<stdin>":9309:9331   */
  swap1
  pop
    /* "<stdin>":9285:9417   */
  jump(tag_43)
tag_45:
    /* "<stdin>":9271:9427   */
  pop
  pop
tag_42:
  jump	// out
    /* "<stdin>":9437:10364   */
tag_21:
  0x00
  dup1
    /* "<stdin>":1307:1318   */
  mload
    /* "<stdin>":4696:4709   */
  0x7350906400000000000000000000000000000000000000000000000000000000
  dup3
    /* "<stdin>":1323:1343   */
  mstore
    /* "<stdin>":1373:1377   */
  0x20
  dup1
  dup4
    /* "<stdin>":1367:1368   */
  0x04
  dup6
  verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
  dup3
    /* "<stdin>":1388:1396   */
  mload
    /* "<stdin>":1411:1416   */
  dup3
  dup5
    /* "<stdin>":1401:1417   */
  mstore
    /* "<stdin>":7935:7953   */
  0x01
  0x01
    /* "<stdin>":9063:9105   */
  0xa0
  shl
  sub
    /* "<stdin>":10779:10784   */
  dup2
    /* "<stdin>":9052:9106   */
  and
  dup5
    /* "<stdin>":14865:14915   */
  mstore
  pop
  dup3
    /* "<stdin>":1373:1377   */
  dup2
    /* "<stdin>":14928:14946   */
  mstore
    /* "<stdin>":14984:14988   */
  0x40
  dup4
    /* "<stdin>":14971:14989   */
  keccak256
    /* "<stdin>":14959:14989   */
  swap2
  pop
    /* "<stdin>":6102:6134   */
  tag_48
    /* "<stdin>":17818:17822   */
  dup3
    /* "<stdin>":6102:6134   */
  tag_23
  jump	// in
tag_48:
  pop
    /* "<stdin>":17762:17868   */
  tag_49
    /* "<stdin>":17779:17867   */
  dup5
    /* "<stdin>":17773:17777   */
  dup4
    /* "<stdin>":17762:17868   */
  tag_34
  jump	// in
tag_49:
    /* "<stdin>":6102:6134   */
  tag_50
  tag_25
  jump	// in
tag_50:
  pop
    /* "<stdin>":17762:17868   */
  tag_51
    /* "<stdin>":17779:17867   */
  dup5
    /* "<stdin>":17762:17868   */
  tag_30
  jump	// in
tag_51:
    /* "<stdin>":11581:11584   */
  dup5
    /* "<stdin>":8949:8961   */
  mload
    /* "<stdin>":11534:11585   */
  swap2
  pop
    /* "<stdin>":7935:7953   */
  sub(shl(0x40, 0x01), 0x01)
    /* "<stdin>":11650:11656   */
  dup3
    /* "<stdin>":11647:11677   */
  gt
    /* "<stdin>":11644:11646   */
  iszero
  tag_52
  jumpi
    /* "<stdin>":11680:11698   */
  tag_53
  tag_12
  jump	// in
tag_53:
    /* "<stdin>":11644:11646   */
tag_52:
    /* "<stdin>":11728:11770   */
  tag_54
    /* "<stdin>":6102:6134   */
  tag_55
  tag_27
  jump	// in
tag_55:
    /* "<stdin>":11728:11770   */
  tag_56
  jump	// in
tag_54:
  dup4
    /* "<stdin>":1373:1377   */
  dup3
    /* "<stdin>":11816:11833   */
  swap1
  pop
  dup5
    /* "<stdin>":11959:11961   */
  0x1f
    /* "<stdin>":11951:11957   */
  dup6
    /* "<stdin>":11948:11962   */
  gt
    /* "<stdin>":11959:11961   */
  0x1f
    /* "<stdin>":11935:11941   */
  dup5
    /* "<stdin>":11932:11946   */
  gt
    /* "<stdin>":11948:11962   */
  dup2
    /* "<stdin>":11932:11946   */
  dup2
    /* "<stdin>":11929:11963   */
  or
    /* "<stdin>":11926:11928   */
  iszero
  tag_57
  jumpi
    /* "<stdin>":11997:12034   */
  tag_58
  tag_39
  jump	// in
tag_58:
    /* "<stdin>":11982:12034   */
  swap3
  pop
    /* "<stdin>":11926:11928   */
tag_57:
    /* "<stdin>":12065:12079   */
  dup1
    /* "<stdin>":12062:12064   */
  iszero
  tag_59
  jumpi
    /* "<stdin>":11959:11961   */
  0x1f
    /* "<stdin>":12187:12193   */
  dup8
    /* "<stdin>":12183:12198   */
  add
    /* "<stdin>":12179:12203   */
  0x05
  shr
    /* "<stdin>":12166:12177   */
  dup4
    /* "<stdin>":12162:12204   */
  add
    /* "<stdin>":1373:1377   */
  dup7
    /* "<stdin>":12227:12233   */
  dup9
    /* "<stdin>":12224:12238   */
  lt
    /* "<stdin>":12221:12223   */
  iszero
  tag_60
  jumpi
    /* "<stdin>":12241:12267   */
  dup4
  swap1
  pop
    /* "<stdin>":12221:12223   */
tag_60:
    /* "<stdin>":12286:12371   */
  tag_61
    /* "<stdin>":11959:11961   */
  0x1f
    /* "<stdin>":12353:12359   */
  dup8
    /* "<stdin>":12349:12364   */
  add
    /* "<stdin>":12179:12203   */
  0x05
    /* "<stdin>":12345:12369   */
  shr
    /* "<stdin>":12332:12343   */
  dup6
    /* "<stdin>":12328:12370   */
  add
    /* "<stdin>":12315:12326   */
  dup3
    /* "<stdin>":12286:12371   */
  tag_41
  jump	// in
tag_61:
  pop
    /* "<stdin>":12062:12064   */
tag_59:
  pop
    /* "<stdin>":12405:12419   */
  dup1
    /* "<stdin>":12437:12438   */
  0x01
    /* "<stdin>":12432:13092   */
  dup2
  eq
  tag_63
  jumpi
  dup8
    /* "<stdin>":13131:13145   */
  swap5
  pop
    /* "<stdin>":13165:13171   */
  dup7
    /* "<stdin>":13162:13164   */
  iszero
  tag_64
  jumpi
    /* "<stdin>":13218:13227   */
  dup4
    /* "<stdin>":13213:13216   */
  dup11
    /* "<stdin>":13209:13228   */
  add
    /* "<stdin>":13203:13229   */
  mload
    /* "<stdin>":13194:13229   */
  swap5
  pop
    /* "<stdin>":13162:13164   */
tag_64:
    /* "<stdin>":13264:13349   */
  tag_65
    /* "<stdin>":13281:13348   */
  tag_66
    /* "<stdin>":13341:13347   */
  dup9
    /* "<stdin>":13334:13339   */
  dup8
    /* "<stdin>":13281:13348   */
  tag_67
  jump	// in
tag_66:
    /* "<stdin>":13264:13349   */
  tag_32
  jump	// in
tag_65:
    /* "<stdin>":12398:13363   */
  jump(tag_62)
    /* "<stdin>":12432:13092   */
tag_63:
    /* "<stdin>":16014:16021   */
  not(0x1f)
    /* "<stdin>":12476:12482   */
  dup8
    /* "<stdin>":12472:12494   */
  and
    /* "<stdin>":12457:12494   */
  swap5
  pop
    /* "<stdin>":12512:12537   */
  dup3
  dup9
    /* "<stdin>":12581:12809   */
tag_68:
    /* "<stdin>":12595:12602   */
  dup7
    /* "<stdin>":12592:12593   */
  dup2
    /* "<stdin>":12589:12603   */
  lt
    /* "<stdin>":12581:12809   */
  iszero
  tag_70
  jumpi
    /* "<stdin>":12648:12694   */
  tag_71
    /* "<stdin>":12682:12691   */
  dup7
    /* "<stdin>":12677:12680   */
  dup14
    /* "<stdin>":12673:12692   */
  add
    /* "<stdin>":12667:12693   */
  mload
    /* "<stdin>":12659:12665   */
  dup4
    /* "<stdin>":12648:12694   */
  tag_34
  jump	// in
tag_71:
    /* "<stdin>":12737:12738   */
  0x01
    /* "<stdin>":12729:12735   */
  dup3
    /* "<stdin>":12725:12739   */
  add
    /* "<stdin>":12715:12739   */
  swap2
  pop
    /* "<stdin>":1373:1377   */
  dup8
    /* "<stdin>":12777:12786   */
  dup7
    /* "<stdin>":12773:12791   */
  add
    /* "<stdin>":12760:12791   */
  swap6
  pop
    /* "<stdin>":12581:12809   */
tag_69:
    /* "<stdin>":1373:1377   */
  dup8
    /* "<stdin>":12615:12616   */
  dup2
    /* "<stdin>":12611:12623   */
  add
    /* "<stdin>":12606:12623   */
  swap1
  pop
    /* "<stdin>":12581:12809   */
  jump(tag_68)
tag_70:
    /* "<stdin>":12585:12588   */
  pop
    /* "<stdin>":12841:12847   */
  dup8
    /* "<stdin>":12832:12839   */
  dup7
    /* "<stdin>":12829:12848   */
  lt
    /* "<stdin>":12826:12828   */
  iszero
  tag_72
  jumpi
    /* "<stdin>":12903:12912   */
  dup5
    /* "<stdin>":12898:12901   */
  dup12
    /* "<stdin>":12894:12913   */
  add
    /* "<stdin>":12888:12914   */
  mload
    /* "<stdin>":12935:13003   */
  tag_73
    /* "<stdin>":15134:15140   */
  not(0x00)
    /* "<stdin>":15119:15132   */
  0xf8
    /* "<stdin>":12988:12994   */
  dup12
    /* "<stdin>":10262:10266   */
  0x03
    /* "<stdin>":15119:15132   */
  shl
  and
    /* "<stdin>":16387:16403   */
  shr
    /* "<stdin>":15086:15142   */
  not
    /* "<stdin>":12973:12982   */
  dup3
    /* "<stdin>":15165:15180   */
  and
    /* "<stdin>":12946:12952   */
  dup4
    /* "<stdin>":12935:13003   */
  tag_34
  jump	// in
tag_73:
  pop
    /* "<stdin>":12826:12828   */
tag_72:
  pop
    /* "<stdin>":13038:13078   */
  tag_74
    /* "<stdin>":12737:12738   */
  0x01
    /* "<stdin>":13063:13069   */
  dup9
    /* "<stdin>":12737:12738   */
  0x01
    /* "<stdin>":13059:13073   */
  shl
    /* "<stdin>":13055:13077   */
  add
    /* "<stdin>":13038:13078   */
  tag_32
  jump	// in
tag_74:
    /* "<stdin>":12398:13363   */
tag_62:
  pop
  pop
  pop
  pop
  pop
  pop
  pop
  pop
    /* "<stdin>":9510:10364   */
  pop
  pop
tag_47:
  jump	// out
    /* "<stdin>":13744:14100   */
tag_56:
    /* "<stdin>":13788:13794   */
  0x00
    /* "<stdin>":13823:13827   */
  dup2
    /* "<stdin>":13819:13831   */
  0x01
  shr
    /* "<stdin>":13809:13831   */
  swap1
  pop
    /* "<stdin>":13819:13831   */
  0x01
    /* "<stdin>":13874:13878   */
  dup3
    /* "<stdin>":13870:13882   */
  and
    /* "<stdin>":13905:13923   */
  dup1
    /* "<stdin>":13898:13924   */
  iszero
    /* "<stdin>":13895:13897   */
  iszero
  tag_76
  jumpi
    /* "<stdin>":13965:13969   */
  0x7f
    /* "<stdin>":13957:13963   */
  dup3
    /* "<stdin>":13953:13970   */
  and
    /* "<stdin>":13943:13970   */
  swap2
  pop
    /* "<stdin>":13895:13897   */
tag_76:
    /* "<stdin>":14035:14037   */
  0x20
    /* "<stdin>":14027:14033   */
  dup3
    /* "<stdin>":14024:14038   */
  lt
    /* "<stdin>":14004:14022   */
  dup2
    /* "<stdin>":14001:14039   */
  eq
    /* "<stdin>":13998:14000   */
  iszero
  tag_77
  jumpi
    /* "<stdin>":15461:15538   */
  shl(0xe0, 0x4e487b71)
    /* "<stdin>":15458:15459   */
  0x00
    /* "<stdin>":15451:15539   */
  mstore
    /* "<stdin>":15562:15566   */
  0x22
    /* "<stdin>":15559:15560   */
  0x04
    /* "<stdin>":15552:15567   */
  mstore
    /* "<stdin>":5759:5768   */
  invalid
    /* "<stdin>":13998:14000   */
tag_77:
  pop
    /* "<stdin>":13795:14100   */
tag_75:
  swap2
  swap1
  pop
  jump	// out
    /* "<stdin>":14110:14425   */
tag_67:
    /* "<stdin>":14186:14190   */
  0x00
    /* "<stdin>":14410:14413   */
  dup3
    /* "<stdin>":14403:14414   */
  0x01
  shl
    /* "<stdin>":15134:15140   */
  not(0x00)
    /* "<stdin>":14369:14372   */
  dup5
    /* "<stdin>":15119:15132   */
  0x03
  shl
    /* "<stdin>":16387:16403   */
  shr
    /* "<stdin>":15086:15142   */
  not
    /* "<stdin>":14363:14367   */
  dup4
    /* "<stdin>":15165:15180   */
  and
    /* "<stdin>":14394:14415   */
  or
    /* "<stdin>":14386:14415   */
  swap1
  pop
    /* "<stdin>":14191:14425   */
tag_78:
  swap3
  swap2
  pop
  pop
  jump	// out
    /* "<stdin>":15619:15819   */
tag_12:
    /* "<stdin>":15461:15538   */
  shl(0xe0, 0x4e487b71)
    /* "<stdin>":15668:15669   */
  0x00
    /* "<stdin>":15661:15749   */
  mstore
    /* "<stdin>":15772:15776   */
  0x41
    /* "<stdin>":15769:15770   */
  0x04
    /* "<stdin>":15762:15777   */
  mstore
    /* "<stdin>":5759:5768   */
  invalid
    /* "<stdin>":15647:15819   */
tag_79:
  jump	// out
tag_22:
stop

sub_0: assembly {
        /* "<stdin>":24388:24390   */
      0x40
        /* "<stdin>":24392:24395   */
      0x80
        /* "<stdin>":24388:24390   */
      dup2
        /* "<stdin>":24381:24396   */
      mstore
        /* "<stdin>":24439:24440   */
      0x04
        /* "<stdin>":24423:24437   */
      calldatasize
        /* "<stdin>":24420:24441   */
      lt
        /* "<stdin>":24413:24442   */
      iszero
        /* "<stdin>":24410:24412   */
      iszero
      tag_1
      jumpi
        /* "<stdin>":24527:24528   */
      0x00
        /* "<stdin>":24514:24529   */
      calldataload
        /* "<stdin>":57388:57391   */
      0xe0
        /* "<stdin>":57384:57399   */
      shr
        /* "<stdin>":24585:24595   */
      0x06fdde03
        /* "<stdin>":24580:25067   */
      dup2
      eq
      tag_3
      jumpi
        /* "<stdin>":25090:25100   */
      0x095ea7b3
        /* "<stdin>":25085:25620   */
      dup2
      eq
      tag_4
      jumpi
        /* "<stdin>":25643:25653   */
      0x18160ddd
        /* "<stdin>":25638:26119   */
      dup2
      eq
      tag_5
      jumpi
        /* "<stdin>":26142:26152   */
      0x23b872dd
        /* "<stdin>":26137:26717   */
      dup2
      eq
      tag_6
      jumpi
        /* "<stdin>":26740:26750   */
      0x27e235e3
        /* "<stdin>":26735:27253   */
      dup2
      eq
      tag_7
      jumpi
        /* "<stdin>":27276:27286   */
      0x55b6ed5c
        /* "<stdin>":27271:27828   */
      dup2
      eq
      tag_8
      jumpi
        /* "<stdin>":27851:27861   */
      0x70a08231
        /* "<stdin>":27846:28359   */
      dup2
      eq
      tag_9
      jumpi
        /* "<stdin>":28382:28392   */
      0xa9059cbb
        /* "<stdin>":28377:28914   */
      dup2
      eq
      tag_10
      jumpi
        /* "<stdin>":28937:28947   */
      0xdd62ed3e
        /* "<stdin>":28932:29481   */
      dup2
      eq
      tag_11
      jumpi
        /* "<stdin>":24547:29509   */
      jump(tag_2)
        /* "<stdin>":24580:25067   */
    tag_3:
        /* "<stdin>":24725:24761   */
      tag_12
        /* "<stdin>":24423:24437   */
      calldatasize
        /* "<stdin>":24725:24761   */
      tag_13
      jump	// in
    tag_12:
        /* "<stdin>":52521:52587   */
      tag_14
      tag_15
      jump	// in
    tag_14:
        /* "<stdin>":24388:24390   */
      dup3
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":25041:25047   */
      dup1
        /* "<stdin>":24906:24993   */
      tag_16
        /* "<stdin>":24987:24992   */
      dup4
        /* "<stdin>":24978:24984   */
      dup4
        /* "<stdin>":24906:24993   */
      tag_17
      jump	// in
    tag_16:
        /* "<stdin>":25029:25048   */
      sub
        /* "<stdin>":25021:25027   */
      dup2
        /* "<stdin>":25014:25049   */
      return
      pop
      pop
        /* "<stdin>":24580:25067   */
      jump(tag_2)
        /* "<stdin>":25085:25620   */
    tag_4:
        /* "<stdin>":25273:25327   */
      tag_18
        /* "<stdin>":24423:24437   */
      calldatasize
        /* "<stdin>":25273:25327   */
      tag_19
      jump	// in
    tag_18:
        /* "<stdin>":25362:25395   */
      tag_20
        /* "<stdin>":25387:25394   */
      dup2
        /* "<stdin>":25378:25385   */
      dup4
        /* "<stdin>":25362:25395   */
      tag_21
      jump	// in
    tag_20:
        /* "<stdin>":25348:25395   */
      swap2
      pop
      pop
        /* "<stdin>":24388:24390   */
      dup3
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":25594:25600   */
      dup1
        /* "<stdin>":25485:25546   */
      tag_22
        /* "<stdin>":25540:25545   */
      dup4
        /* "<stdin>":25531:25537   */
      dup4
        /* "<stdin>":25485:25546   */
      tag_23
      jump	// in
    tag_22:
        /* "<stdin>":25582:25601   */
      sub
        /* "<stdin>":25574:25580   */
      dup2
        /* "<stdin>":25567:25602   */
      return
      pop
      pop
        /* "<stdin>":25085:25620   */
      jump(tag_2)
        /* "<stdin>":25638:26119   */
    tag_5:
        /* "<stdin>":25790:25826   */
      tag_24
        /* "<stdin>":24423:24437   */
      calldatasize
        /* "<stdin>":25790:25826   */
      tag_13
      jump	// in
    tag_24:
        /* "<stdin>":24193:24225   */
      tag_25
      tag_26
      jump	// in
    tag_25:
        /* "<stdin>":24388:24390   */
      dup3
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":26093:26099   */
      dup1
        /* "<stdin>":25978:26045   */
      tag_27
        /* "<stdin>":26039:26044   */
      dup4
        /* "<stdin>":26030:26036   */
      dup4
        /* "<stdin>":25978:26045   */
      tag_28
      jump	// in
    tag_27:
        /* "<stdin>":26081:26100   */
      sub
        /* "<stdin>":26073:26079   */
      dup2
        /* "<stdin>":26066:26101   */
      return
      pop
      pop
        /* "<stdin>":25638:26119   */
      jump(tag_2)
        /* "<stdin>":26137:26717   */
    tag_6:
        /* "<stdin>":26347:26410   */
      tag_29
        /* "<stdin>":24423:24437   */
      calldatasize
        /* "<stdin>":26347:26410   */
      tag_30
      jump	// in
    tag_29:
        /* "<stdin>":26445:26492   */
      tag_31
        /* "<stdin>":26484:26491   */
      dup2
        /* "<stdin>":26475:26482   */
      dup4
        /* "<stdin>":26466:26473   */
      dup6
        /* "<stdin>":26445:26492   */
      tag_32
      jump	// in
    tag_31:
        /* "<stdin>":26431:26492   */
      swap3
      pop
      pop
      pop
        /* "<stdin>":24388:24390   */
      dup3
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":26691:26697   */
      dup1
        /* "<stdin>":26582:26643   */
      tag_33
        /* "<stdin>":26637:26642   */
      dup4
        /* "<stdin>":26628:26634   */
      dup4
        /* "<stdin>":26582:26643   */
      tag_23
      jump	// in
    tag_33:
        /* "<stdin>":26679:26698   */
      sub
        /* "<stdin>":26671:26677   */
      dup2
        /* "<stdin>":26664:26699   */
      return
      pop
      pop
        /* "<stdin>":26137:26717   */
      jump(tag_2)
        /* "<stdin>":26735:27253   */
    tag_7:
        /* "<stdin>":26991:27022   */
      tag_34
        /* "<stdin>":26907:26956   */
      tag_35
        /* "<stdin>":24423:24437   */
      calldatasize
        /* "<stdin>":26907:26956   */
      tag_36
      jump	// in
    tag_35:
        /* "<stdin>":26991:27022   */
      tag_37
      jump	// in
    tag_34:
        /* "<stdin>":24388:24390   */
      dup3
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":27227:27233   */
      dup1
        /* "<stdin>":27112:27179   */
      tag_38
        /* "<stdin>":27173:27178   */
      dup4
        /* "<stdin>":27164:27170   */
      dup4
        /* "<stdin>":27112:27179   */
      tag_28
      jump	// in
    tag_38:
        /* "<stdin>":27215:27234   */
      sub
        /* "<stdin>":27207:27213   */
      dup2
        /* "<stdin>":27200:27235   */
      return
      pop
      pop
        /* "<stdin>":26735:27253   */
      jump(tag_2)
        /* "<stdin>":27271:27828   */
    tag_8:
        /* "<stdin>":27462:27520   */
      tag_39
        /* "<stdin>":24423:24437   */
      calldatasize
        /* "<stdin>":27462:27520   */
      tag_40
      jump	// in
    tag_39:
        /* "<stdin>":51971:52026   */
      tag_41
        /* "<stdin>":51861:51946   */
      tag_42
        /* "<stdin>":27589:27596   */
      dup3
        /* "<stdin>":51725:51835   */
      tag_43
        /* "<stdin>":27580:27587   */
      dup6
        /* "<stdin>":51725:51835   */
      tag_44
      jump	// in
    tag_43:
        /* "<stdin>":51861:51946   */
      tag_45
      jump	// in
    tag_42:
        /* "<stdin>":51971:52026   */
      tag_46
      jump	// in
    tag_41:
        /* "<stdin>":27541:27597   */
      swap2
      pop
      pop
        /* "<stdin>":24388:24390   */
      dup3
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":27802:27808   */
      dup1
        /* "<stdin>":27687:27754   */
      tag_47
        /* "<stdin>":27748:27753   */
      dup4
        /* "<stdin>":27739:27745   */
      dup4
        /* "<stdin>":27687:27754   */
      tag_28
      jump	// in
    tag_47:
        /* "<stdin>":27790:27809   */
      sub
        /* "<stdin>":27782:27788   */
      dup2
        /* "<stdin>":27775:27810   */
      return
      pop
      pop
        /* "<stdin>":27271:27828   */
      jump(tag_2)
        /* "<stdin>":27846:28359   */
    tag_9:
        /* "<stdin>":28103:28128   */
      tag_48
        /* "<stdin>":28019:28068   */
      tag_49
        /* "<stdin>":24423:24437   */
      calldatasize
        /* "<stdin>":28019:28068   */
      tag_36
      jump	// in
    tag_49:
        /* "<stdin>":28103:28128   */
      tag_50
      jump	// in
    tag_48:
        /* "<stdin>":24388:24390   */
      dup3
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":28333:28339   */
      dup1
        /* "<stdin>":28218:28285   */
      tag_51
        /* "<stdin>":28279:28284   */
      dup4
        /* "<stdin>":28270:28276   */
      dup4
        /* "<stdin>":28218:28285   */
      tag_28
      jump	// in
    tag_51:
        /* "<stdin>":28321:28340   */
      sub
        /* "<stdin>":28313:28319   */
      dup2
        /* "<stdin>":28306:28341   */
      return
      pop
      pop
        /* "<stdin>":27846:28359   */
      jump(tag_2)
        /* "<stdin>":28377:28914   */
    tag_10:
        /* "<stdin>":28566:28620   */
      tag_52
        /* "<stdin>":24423:24437   */
      calldatasize
        /* "<stdin>":28566:28620   */
      tag_19
      jump	// in
    tag_52:
        /* "<stdin>":28655:28689   */
      tag_53
        /* "<stdin>":28681:28688   */
      dup2
        /* "<stdin>":28672:28679   */
      dup4
        /* "<stdin>":28655:28689   */
      tag_54
      jump	// in
    tag_53:
        /* "<stdin>":28641:28689   */
      swap2
      pop
      pop
        /* "<stdin>":24388:24390   */
      dup3
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":28888:28894   */
      dup1
        /* "<stdin>":28779:28840   */
      tag_55
        /* "<stdin>":28834:28839   */
      dup4
        /* "<stdin>":28825:28831   */
      dup4
        /* "<stdin>":28779:28840   */
      tag_23
      jump	// in
    tag_55:
        /* "<stdin>":28876:28895   */
      sub
        /* "<stdin>":28868:28874   */
      dup2
        /* "<stdin>":28861:28896   */
      return
      pop
      pop
        /* "<stdin>":28377:28914   */
      jump(tag_2)
        /* "<stdin>":28932:29481   */
    tag_11:
        /* "<stdin>":29122:29180   */
      tag_56
        /* "<stdin>":24423:24437   */
      calldatasize
        /* "<stdin>":29122:29180   */
      tag_40
      jump	// in
    tag_56:
        /* "<stdin>":24193:24225   */
      tag_57
        /* "<stdin>":42766:42857   */
      tag_58
        /* "<stdin>":29242:29249   */
      dup3
        /* "<stdin>":42475:42591   */
      tag_59
        /* "<stdin>":29233:29240   */
      dup6
        /* "<stdin>":42475:42591   */
      tag_60
      jump	// in
    tag_59:
        /* "<stdin>":42766:42857   */
      tag_45
      jump	// in
    tag_58:
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_57:
        /* "<stdin>":54986:55056   */
      swap2
      pop
      pop
        /* "<stdin>":24388:24390   */
      dup3
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":29455:29461   */
      dup1
        /* "<stdin>":29340:29407   */
      tag_62
        /* "<stdin>":29401:29406   */
      dup4
        /* "<stdin>":29392:29398   */
      dup4
        /* "<stdin>":29340:29407   */
      tag_28
      jump	// in
    tag_62:
        /* "<stdin>":29443:29462   */
      sub
        /* "<stdin>":29435:29441   */
      dup2
        /* "<stdin>":29428:29463   */
      return
      pop
      pop
        /* "<stdin>":24547:29509   */
    tag_2:
      pop
        /* "<stdin>":24410:24412   */
    tag_1:
      pop
        /* "<stdin>":29579:29595   */
      tag_63
      tag_64
      jump	// in
    tag_63:
        /* "<stdin>":19342:19510   */
      jump(tag_65)
    tag_66:
        /* "<stdin>":19377:19378   */
      0x00
      dup1
        /* "<stdin>":19398:19409   */
      mload
        /* "<stdin>":22787:22800   */
      0x7350906400000000000000000000000000000000000000000000000000000000
      dup3
        /* "<stdin>":19414:19434   */
      mstore
        /* "<stdin>":19464:19468   */
      0x20
      dup3
        /* "<stdin>":19458:19459   */
      0x04
      dup5
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
      dup2
        /* "<stdin>":19479:19487   */
      mload
        /* "<stdin>":19474:19487   */
      swap2
      pop
        /* "<stdin>":19502:19507   */
      dup1
        /* "<stdin>":19499:19500   */
      0x00
        /* "<stdin>":19492:19508   */
      mstore
      pop
        /* "<stdin>":19379:19510   */
    tag_67:
      swap1
      jump	// out
        /* "<stdin>":19765:20015   */
    tag_26:
        /* "<stdin>":19806:19807   */
      0x00
      dup1
        /* "<stdin>":19827:19838   */
      mload
        /* "<stdin>":19862:19866   */
      0x20
        /* "<stdin>":19856:19867   */
      mload
        /* "<stdin>":24208:24221   */
      0x03daa95900000000000000000000000000000000000000000000000000000000
      dup4
        /* "<stdin>":19872:19892   */
      mstore
        /* "<stdin>":52691:52692   */
      0x02
        /* "<stdin>":19904:19905   */
      0x04
        /* "<stdin>":19897:19909   */
      mstore
        /* "<stdin>":19862:19866   */
      0x20
      dup4
        /* "<stdin>":19933:19937   */
      0x24
      dup6
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
      dup3
        /* "<stdin>":19957:19965   */
      mload
        /* "<stdin>":19952:19965   */
      swap3
      pop
        /* "<stdin>":19983:19988   */
      dup2
        /* "<stdin>":19977:19981   */
      0x00
        /* "<stdin>":19970:19989   */
      mstore
        /* "<stdin>":20007:20012   */
      dup1
        /* "<stdin>":19862:19866   */
      0x20
        /* "<stdin>":19994:20013   */
      mstore
      pop
      pop
        /* "<stdin>":19808:20015   */
    tag_68:
      swap1
      jump	// out
        /* "<stdin>":19765:20015   */
    tag_69:
        /* "<stdin>":19806:19807   */
      0x00
      dup1
        /* "<stdin>":19827:19838   */
      mload
        /* "<stdin>":19862:19866   */
      0x20
        /* "<stdin>":19856:19867   */
      mload
        /* "<stdin>":24208:24221   */
      0x03daa95900000000000000000000000000000000000000000000000000000000
      dup4
        /* "<stdin>":19872:19892   */
      mstore
        /* "<stdin>":52458:52459   */
      0x03
        /* "<stdin>":19904:19905   */
      0x04
        /* "<stdin>":19897:19909   */
      mstore
        /* "<stdin>":19862:19866   */
      0x20
      dup4
        /* "<stdin>":19933:19937   */
      0x24
      dup6
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
      dup3
        /* "<stdin>":19957:19965   */
      mload
        /* "<stdin>":19952:19965   */
      swap3
      pop
        /* "<stdin>":19983:19988   */
      dup2
        /* "<stdin>":19977:19981   */
      0x00
        /* "<stdin>":19970:19989   */
      mstore
        /* "<stdin>":20007:20012   */
      dup1
        /* "<stdin>":19862:19866   */
      0x20
        /* "<stdin>":19994:20013   */
      mstore
      pop
      pop
        /* "<stdin>":19808:20015   */
    tag_70:
      swap1
      jump	// out
        /* "<stdin>":19765:20015   */
    tag_61:
        /* "<stdin>":19806:19807   */
      0x00
      dup1
        /* "<stdin>":19827:19838   */
      mload
        /* "<stdin>":19862:19866   */
      0x20
        /* "<stdin>":19856:19867   */
      mload
        /* "<stdin>":24208:24221   */
      0x03daa95900000000000000000000000000000000000000000000000000000000
      dup4
        /* "<stdin>":19872:19892   */
      mstore
        /* "<stdin>":19907:19908   */
      dup4
        /* "<stdin>":19904:19905   */
      0x04
        /* "<stdin>":19897:19909   */
      mstore
        /* "<stdin>":19862:19866   */
      0x20
      dup4
        /* "<stdin>":19933:19937   */
      0x24
      dup6
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
      dup3
        /* "<stdin>":19957:19965   */
      mload
        /* "<stdin>":19952:19965   */
      swap3
      pop
        /* "<stdin>":19983:19988   */
      dup2
        /* "<stdin>":19977:19981   */
      0x00
        /* "<stdin>":19970:19989   */
      mstore
        /* "<stdin>":20007:20012   */
      dup1
        /* "<stdin>":19862:19866   */
      0x20
        /* "<stdin>":19994:20013   */
      mstore
      pop
      pop
        /* "<stdin>":19808:20015   */
    tag_71:
      swap2
      swap1
      pop
      jump	// out
        /* "<stdin>":23430:24153   */
    tag_64:
        /* "<stdin>":23605:23615   */
      0x3261326137616462000000000000000000000000000000000000000000000000
        /* "<stdin>":23786:23806   */
      0x00
        /* "<stdin>":23915:23951   */
      mstore
        /* "<stdin>":23985:23989   */
      0x20
        /* "<stdin>":23963:23983   */
      0x04
        /* "<stdin>":23956:23990   */
      mstore
        /* "<stdin>":23786:23806   */
      0x00
        /* "<stdin>":24002:24022   */
      0x24
        /* "<stdin>":23995:24031   */
      mstore
        /* "<stdin>":23786:23806   */
      0x00
      0x00
        /* "<stdin>":23488:23492   */
      0x64
        /* "<stdin>":23786:23806   */
      0x00
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
        /* "<stdin>":24142:24151   */
      invalid
        /* "<stdin>":23464:24153   */
    tag_72:
      jump	// out
        /* "<stdin>":23430:24153   */
    tag_73:
        /* "<stdin>":23488:23492   */
      0x64
        /* "<stdin>":23789:23793   */
      dup2
        /* "<stdin>":23786:23806   */
      lt
        /* "<stdin>":23783:23785   */
      iszero
      tag_75
      jumpi
        /* "<stdin>":23850:23859   */
      invalid
        /* "<stdin>":23783:23785   */
    tag_75:
        /* "<stdin>":23888:23909   */
      not(0x63)
        /* "<stdin>":23892:23896   */
      dup2
        /* "<stdin>":23888:23909   */
      add
        /* "<stdin>":23605:23615   */
      0x3261326137616462000000000000000000000000000000000000000000000000
        /* "<stdin>":23922:23939   */
      dup2
        /* "<stdin>":23915:23951   */
      mstore
        /* "<stdin>":23985:23989   */
      0x20
        /* "<stdin>":23963:23983   */
      not(0x5f)
        /* "<stdin>":23892:23896   */
      dup4
        /* "<stdin>":23963:23983   */
      add
        /* "<stdin>":23956:23990   */
      mstore
        /* "<stdin>":34731:34743   */
      0xa4
        /* "<stdin>":24002:24022   */
      not(0x3f)
        /* "<stdin>":23892:23896   */
      dup4
        /* "<stdin>":24002:24022   */
      add
        /* "<stdin>":23995:24031   */
      mstore
        /* "<stdin>":23500:23514   */
      0x00
      0x00
        /* "<stdin>":24063:24086   */
      0x0108
        /* "<stdin>":18689:18698   */
      dup4
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
      pop
        /* "<stdin>":24142:24151   */
      invalid
        /* "<stdin>":23464:24153   */
      pop
    tag_74:
      jump	// out
        /* "<stdin>":23430:24153   */
    tag_76:
        /* "<stdin>":23488:23492   */
      0x64
        /* "<stdin>":23789:23793   */
      dup2
        /* "<stdin>":23786:23806   */
      lt
        /* "<stdin>":23783:23785   */
      iszero
      tag_78
      jumpi
        /* "<stdin>":23850:23859   */
      invalid
        /* "<stdin>":23783:23785   */
    tag_78:
        /* "<stdin>":23888:23909   */
      not(0x63)
        /* "<stdin>":23892:23896   */
      dup2
        /* "<stdin>":23888:23909   */
      add
        /* "<stdin>":23605:23615   */
      0x3261326137616462000000000000000000000000000000000000000000000000
        /* "<stdin>":23922:23939   */
      dup2
        /* "<stdin>":23915:23951   */
      mstore
        /* "<stdin>":23985:23989   */
      0x20
        /* "<stdin>":23963:23983   */
      not(0x5f)
        /* "<stdin>":23892:23896   */
      dup4
        /* "<stdin>":23963:23983   */
      add
        /* "<stdin>":23956:23990   */
      mstore
        /* "<stdin>":35143:35155   */
      0x84
        /* "<stdin>":24002:24022   */
      not(0x3f)
        /* "<stdin>":23892:23896   */
      dup4
        /* "<stdin>":24002:24022   */
      add
        /* "<stdin>":23995:24031   */
      mstore
        /* "<stdin>":23500:23514   */
      0x00
      0x00
        /* "<stdin>":24063:24086   */
      0xe8
        /* "<stdin>":18689:18698   */
      dup4
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
      pop
        /* "<stdin>":24142:24151   */
      invalid
        /* "<stdin>":23464:24153   */
      pop
    tag_77:
      jump	// out
        /* "<stdin>":29971:30108   */
    tag_13:
        /* "<stdin>":30070:30071   */
      0x00
        /* "<stdin>":30045:30068   */
      not(0x03)
        /* "<stdin>":30049:30056   */
      dup3
        /* "<stdin>":30045:30068   */
      add
        /* "<stdin>":30041:30072   */
      slt
        /* "<stdin>":30038:30040   */
      iszero
      tag_80
      jumpi
        /* "<stdin>":30075:30091   */
      tag_81
      tag_64
      jump	// in
    tag_81:
        /* "<stdin>":30038:30040   */
    tag_80:
        /* "<stdin>":30020:30108   */
      pop
    tag_79:
      jump	// out
        /* "<stdin>":30122:30444   */
    tag_36:
        /* "<stdin>":30185:30191   */
      0x00
        /* "<stdin>":30242:30244   */
      0x20
        /* "<stdin>":30045:30068   */
      not(0x03)
        /* "<stdin>":30221:30228   */
      dup4
        /* "<stdin>":30217:30240   */
      add
        /* "<stdin>":30213:30245   */
      slt
        /* "<stdin>":30210:30212   */
      iszero
      tag_83
      jumpi
        /* "<stdin>":30248:30264   */
      tag_84
      tag_64
      jump	// in
    tag_84:
        /* "<stdin>":30210:30212   */
    tag_83:
        /* "<stdin>":24439:24440   */
      0x04
        /* "<stdin>":29692:29712   */
      calldataload
        /* "<stdin>":39431:39473   */
      sub(shl(0xa0, 0x01), 0x01)
        /* "<stdin>":59324:59329   */
      dup2
        /* "<stdin>":39420:39474   */
      and
        /* "<stdin>":59295:59300   */
      dup2
        /* "<stdin>":59292:59331   */
      eq
        /* "<stdin>":59285:59332   */
      iszero
        /* "<stdin>":59282:59284   */
      iszero
      tag_85
      jumpi
        /* "<stdin>":59335:59351   */
      tag_86
      tag_64
      jump	// in
    tag_86:
        /* "<stdin>":59282:59284   */
    tag_85:
        /* "<stdin>":30344:30411   */
      dup1
      swap2
      pop
      pop
        /* "<stdin>":30192:30444   */
    tag_82:
      swap2
      swap1
      pop
      jump	// out
        /* "<stdin>":30458:30961   */
    tag_40:
        /* "<stdin>":30530:30536   */
      0x00
        /* "<stdin>":30538:30544   */
      0x00
        /* "<stdin>":30595:30597   */
      0x40
        /* "<stdin>":30045:30068   */
      not(0x03)
        /* "<stdin>":30574:30581   */
      dup5
        /* "<stdin>":30570:30593   */
      add
        /* "<stdin>":30566:30598   */
      slt
        /* "<stdin>":30563:30565   */
      iszero
      tag_88
      jumpi
        /* "<stdin>":30601:30617   */
      tag_89
      tag_64
      jump	// in
    tag_89:
        /* "<stdin>":30563:30565   */
    tag_88:
        /* "<stdin>":24439:24440   */
      0x04
        /* "<stdin>":29692:29712   */
      calldataload
        /* "<stdin>":39431:39473   */
      sub(shl(0xa0, 0x01), 0x01)
      dup1
        /* "<stdin>":59324:59329   */
      dup3
        /* "<stdin>":39420:39474   */
      and
        /* "<stdin>":59295:59300   */
      dup3
        /* "<stdin>":59292:59331   */
      eq
        /* "<stdin>":59285:59332   */
      iszero
        /* "<stdin>":59282:59284   */
      iszero
      tag_90
      jumpi
        /* "<stdin>":59335:59351   */
      tag_91
      tag_64
      jump	// in
    tag_91:
        /* "<stdin>":59282:59284   */
    tag_90:
        /* "<stdin>":30697:30764   */
      dup2
      swap4
      pop
        /* "<stdin>":30896:30918   */
      0x24
        /* "<stdin>":29692:29712   */
      calldataload
        /* "<stdin>":29683:29712   */
      swap2
      pop
        /* "<stdin>":39431:39473   */
      dup1
        /* "<stdin>":59324:59329   */
      dup3
        /* "<stdin>":39420:39474   */
      and
        /* "<stdin>":59295:59300   */
      dup3
        /* "<stdin>":59292:59331   */
      eq
        /* "<stdin>":59285:59332   */
      iszero
        /* "<stdin>":59282:59284   */
      iszero
      tag_92
      jumpi
        /* "<stdin>":59335:59351   */
      tag_93
      tag_64
      jump	// in
    tag_93:
        /* "<stdin>":59282:59284   */
    tag_92:
      pop
        /* "<stdin>":30861:30928   */
      dup1
      swap2
      pop
      pop
        /* "<stdin>":30545:30961   */
    tag_87:
      swap2
      pop
      swap2
      jump	// out
        /* "<stdin>":30975:31651   */
    tag_30:
        /* "<stdin>":31052:31058   */
      0x00
        /* "<stdin>":31060:31066   */
      0x00
        /* "<stdin>":31068:31074   */
      0x00
        /* "<stdin>":31125:31127   */
      0x60
        /* "<stdin>":30045:30068   */
      not(0x03)
        /* "<stdin>":31104:31111   */
      dup6
        /* "<stdin>":31100:31123   */
      add
        /* "<stdin>":31096:31128   */
      slt
        /* "<stdin>":31093:31095   */
      iszero
      tag_95
      jumpi
        /* "<stdin>":31131:31147   */
      tag_96
      tag_64
      jump	// in
    tag_96:
        /* "<stdin>":31093:31095   */
    tag_95:
        /* "<stdin>":24439:24440   */
      0x04
        /* "<stdin>":29692:29712   */
      calldataload
        /* "<stdin>":39431:39473   */
      sub(shl(0xa0, 0x01), 0x01)
      dup1
        /* "<stdin>":59324:59329   */
      dup3
        /* "<stdin>":39420:39474   */
      and
        /* "<stdin>":59295:59300   */
      dup3
        /* "<stdin>":59292:59331   */
      eq
        /* "<stdin>":59285:59332   */
      iszero
        /* "<stdin>":59282:59284   */
      iszero
      tag_97
      jumpi
        /* "<stdin>":59335:59351   */
      tag_98
      tag_64
      jump	// in
    tag_98:
        /* "<stdin>":59282:59284   */
    tag_97:
        /* "<stdin>":31227:31294   */
      dup2
      swap5
      pop
        /* "<stdin>":31426:31448   */
      0x24
        /* "<stdin>":29692:29712   */
      calldataload
        /* "<stdin>":29683:29712   */
      swap2
      pop
        /* "<stdin>":39431:39473   */
      dup1
        /* "<stdin>":59324:59329   */
      dup3
        /* "<stdin>":39420:39474   */
      and
        /* "<stdin>":59295:59300   */
      dup3
        /* "<stdin>":59292:59331   */
      eq
        /* "<stdin>":59285:59332   */
      iszero
        /* "<stdin>":59282:59284   */
      iszero
      tag_99
      jumpi
        /* "<stdin>":59335:59351   */
      tag_100
      tag_64
      jump	// in
    tag_100:
        /* "<stdin>":59282:59284   */
    tag_99:
      pop
        /* "<stdin>":31391:31458   */
      dup1
      swap3
      pop
      pop
        /* "<stdin>":31586:31608   */
      0x44
        /* "<stdin>":29873:29893   */
      calldataload
        /* "<stdin>":31555:31618   */
      swap1
      pop
        /* "<stdin>":31075:31651   */
    tag_94:
      swap2
      swap4
      swap1
      swap3
      pop
      jump	// out
        /* "<stdin>":31665:32160   */
    tag_19:
        /* "<stdin>":31733:31739   */
      0x00
        /* "<stdin>":31741:31747   */
      0x00
        /* "<stdin>":31798:31800   */
      0x40
        /* "<stdin>":30045:30068   */
      not(0x03)
        /* "<stdin>":31777:31784   */
      dup5
        /* "<stdin>":31773:31796   */
      add
        /* "<stdin>":31769:31801   */
      slt
        /* "<stdin>":31766:31768   */
      iszero
      tag_102
      jumpi
        /* "<stdin>":31804:31820   */
      tag_103
      tag_64
      jump	// in
    tag_103:
        /* "<stdin>":31766:31768   */
    tag_102:
        /* "<stdin>":24439:24440   */
      0x04
        /* "<stdin>":29692:29712   */
      calldataload
        /* "<stdin>":39431:39473   */
      sub(shl(0xa0, 0x01), 0x01)
        /* "<stdin>":59324:59329   */
      dup2
        /* "<stdin>":39420:39474   */
      and
        /* "<stdin>":59295:59300   */
      dup2
        /* "<stdin>":59292:59331   */
      eq
        /* "<stdin>":59285:59332   */
      iszero
        /* "<stdin>":59282:59284   */
      iszero
      tag_104
      jumpi
        /* "<stdin>":59335:59351   */
      tag_105
      tag_64
      jump	// in
    tag_105:
        /* "<stdin>":59282:59284   */
    tag_104:
        /* "<stdin>":31900:31967   */
      dup1
      swap3
      pop
      pop
        /* "<stdin>":32095:32117   */
      0x24
        /* "<stdin>":29873:29893   */
      calldataload
        /* "<stdin>":32064:32127   */
      swap1
      pop
        /* "<stdin>":31748:32160   */
    tag_101:
      swap2
      pop
      swap2
      jump	// out
        /* "<stdin>":35331:35556   */
    tag_23:
        /* "<stdin>":35409:35413   */
      0x00
        /* "<stdin>":35455:35457   */
      0x20
        /* "<stdin>":35444:35453   */
      dup3
        /* "<stdin>":35440:35458   */
      add
        /* "<stdin>":35432:35458   */
      swap1
      pop
        /* "<stdin>":32498:32503   */
      dup3
        /* "<stdin>":39304:39317   */
      iszero
        /* "<stdin>":39297:39318   */
      iszero
        /* "<stdin>":32478:32481   */
      dup3
        /* "<stdin>":32471:32505   */
      mstore
        /* "<stdin>":35414:35556   */
    tag_106:
      swap3
      swap2
      pop
      pop
      jump	// out
        /* "<stdin>":35570:35906   */
    tag_17:
        /* "<stdin>":35674:35678   */
      0x00
        /* "<stdin>":35720:35722   */
      0x20
      dup1
        /* "<stdin>":35748:35765   */
      dup4
        /* "<stdin>":35741:35788   */
      mstore
        /* "<stdin>":32690:32695   */
      dup4
        /* "<stdin>":37919:37931   */
      mload
        /* "<stdin>":38076:38082   */
      dup1
        /* "<stdin>":35720:35722   */
      dup3
        /* "<stdin>":35709:35718   */
      dup6
        /* "<stdin>":35705:35723   */
      add
        /* "<stdin>":38064:38083   */
      mstore
      dup3
        /* "<stdin>":40629:40766   */
    tag_108:
        /* "<stdin>":40643:40649   */
      dup2
        /* "<stdin>":40640:40641   */
      dup2
        /* "<stdin>":40637:40650   */
      lt
        /* "<stdin>":40629:40766   */
      iszero
      tag_110
      jumpi
        /* "<stdin>":35720:35722   */
      dup3
        /* "<stdin>":40744:40745   */
      dup2
        /* "<stdin>":32834:32839   */
      dup8
        /* "<stdin>":40735:40746   */
      add
      add
        /* "<stdin>":40729:40747   */
      mload
        /* "<stdin>":38115:38129   */
      0x40
        /* "<stdin>":40725:40726   */
      dup3
        /* "<stdin>":35709:35718   */
      dup8
        /* "<stdin>":40716:40727   */
      add
      add
        /* "<stdin>":40709:40748   */
      mstore
        /* "<stdin>":40629:40766   */
    tag_109:
        /* "<stdin>":35720:35722   */
      dup3
        /* "<stdin>":40662:40663   */
      dup2
        /* "<stdin>":40658:40668   */
      add
        /* "<stdin>":40653:40668   */
      swap1
      pop
        /* "<stdin>":40629:40766   */
      jump(tag_108)
    tag_110:
        /* "<stdin>":40792:40798   */
      dup2
        /* "<stdin>":40789:40790   */
      dup2
        /* "<stdin>":40786:40799   */
      gt
        /* "<stdin>":40783:40785   */
      iszero
      tag_111
      jumpi
      dup4
        /* "<stdin>":38115:38129   */
      0x40
        /* "<stdin>":40887:40893   */
      dup4
        /* "<stdin>":35709:35718   */
      dup8
        /* "<stdin>":40878:40894   */
      add
      add
        /* "<stdin>":40871:40898   */
      mstore
        /* "<stdin>":40783:40785   */
    tag_111:
      pop
        /* "<stdin>":38115:38129   */
      0x40
        /* "<stdin>":56978:56985   */
      not(0x1f)
        /* "<stdin>":56982:56984   */
      0x1f
        /* "<stdin>":32915:32921   */
      dup4
        /* "<stdin>":56962:56976   */
      add
        /* "<stdin>":56958:56986   */
      and
        /* "<stdin>":35709:35718   */
      dup6
        /* "<stdin>":32884:32923   */
      add
      add
        /* "<stdin>":35805:35891   */
      swap3
      pop
      pop
      pop
        /* "<stdin>":35679:35906   */
    tag_107:
      swap3
      swap2
      pop
      pop
      jump	// out
        /* "<stdin>":37288:37525   */
    tag_28:
        /* "<stdin>":37372:37376   */
      0x00
        /* "<stdin>":37418:37420   */
      0x20
        /* "<stdin>":37407:37416   */
      dup3
        /* "<stdin>":37403:37421   */
      add
        /* "<stdin>":37395:37421   */
      swap1
      pop
        /* "<stdin>":35296:35301   */
      dup3
        /* "<stdin>":35273:35276   */
      dup3
        /* "<stdin>":35266:35303   */
      mstore
        /* "<stdin>":37377:37525   */
    tag_112:
      swap3
      swap2
      pop
      pop
      jump	// out
        /* "<stdin>":37644:37817   */
    tag_113:
        /* "<stdin>":37693:37697   */
      0x00
        /* "<stdin>":52458:52459   */
      0x03
      dup2
        /* "<stdin>":37745:37759   */
      mstore
        /* "<stdin>":37797:37801   */
      0x20
      dup2
        /* "<stdin>":37784:37802   */
      keccak256
        /* "<stdin>":37776:37802   */
      swap1
      pop
        /* "<stdin>":37698:37817   */
    tag_114:
      swap1
      jump	// out
        /* "<stdin>":37960:38143   */
    tag_115:
        /* "<stdin>":38076:38082   */
      dup2
        /* "<stdin>":38071:38074   */
      dup2
        /* "<stdin>":38064:38083   */
      mstore
        /* "<stdin>":38034:38045   */
      0x00
        /* "<stdin>":38124:38128   */
      0x20
        /* "<stdin>":38119:38122   */
      dup3
        /* "<stdin>":38115:38129   */
      add
        /* "<stdin>":38100:38129   */
      swap1
      pop
        /* "<stdin>":38046:38143   */
    tag_116:
      swap3
      swap2
      pop
      pop
      jump	// out
        /* "<stdin>":38364:38717   */
    tag_117:
        /* "<stdin>":38404:38407   */
      0x00
        /* "<stdin>":38643:38644   */
      dup3
        /* "<stdin>":38571:38645   */
      not
        /* "<stdin>":38568:38569   */
      dup3
        /* "<stdin>":38565:38646   */
      gt
        /* "<stdin>":38562:38564   */
      iszero
      tag_119
      jumpi
        /* "<stdin>":38649:38667   */
      tag_120
      tag_121
      jump	// in
    tag_120:
        /* "<stdin>":38562:38564   */
    tag_119:
        /* "<stdin>":38701:38702   */
      dup3
        /* "<stdin>":38698:38699   */
      dup3
        /* "<stdin>":38694:38703   */
      add
        /* "<stdin>":38687:38703   */
      swap1
      pop
        /* "<stdin>":38408:38717   */
    tag_118:
      swap3
      swap2
      pop
      pop
      jump	// out
        /* "<stdin>":38731:38962   */
    tag_122:
        /* "<stdin>":38771:38775   */
      0x00
        /* "<stdin>":38888:38889   */
      dup3
        /* "<stdin>":38885:38886   */
      dup3
        /* "<stdin>":38882:38890   */
      lt
        /* "<stdin>":38879:38881   */
      iszero
      tag_124
      jumpi
        /* "<stdin>":38893:38911   */
      tag_125
      tag_121
      jump	// in
    tag_125:
        /* "<stdin>":38879:38881   */
    tag_124:
        /* "<stdin>":38946:38947   */
      dup3
        /* "<stdin>":38943:38944   */
      dup3
        /* "<stdin>":38939:38948   */
      sub
        /* "<stdin>":38931:38948   */
      swap1
      pop
        /* "<stdin>":38776:38962   */
    tag_123:
      swap3
      swap2
      pop
      pop
      jump	// out
        /* "<stdin>":41771:42092   */
    tag_126:
        /* "<stdin>":56978:56985   */
      not(0x1f)
        /* "<stdin>":56982:56984   */
      0x1f
        /* "<stdin>":41884:41888   */
      dup4
        /* "<stdin>":56962:56976   */
      add
        /* "<stdin>":56958:56986   */
      and
        /* "<stdin>":41854:41860   */
      dup2
        /* "<stdin>":41850:41890   */
      add
        /* "<stdin>":42008:42014   */
      dup2
        /* "<stdin>":41996:42006   */
      dup2
        /* "<stdin>":41993:42015   */
      lt
        /* "<stdin>":41972:41990   */
      0xffffffffffffffff
        /* "<stdin>":41960:41970   */
      dup3
        /* "<stdin>":41957:41991   */
      gt
        /* "<stdin>":41954:42016   */
      or
        /* "<stdin>":41951:41953   */
      iszero
      tag_128
      jumpi
        /* "<stdin>":54172:54249   */
      shl(0xe0, 0x4e487b71)
        /* "<stdin>":54169:54170   */
      0x00
        /* "<stdin>":54162:54250   */
      mstore
        /* "<stdin>":54277:54281   */
      0x41
        /* "<stdin>":54274:54275   */
      0x04
        /* "<stdin>":54267:54282   */
      mstore
        /* "<stdin>":23850:23859   */
      invalid
        /* "<stdin>":41951:41953   */
    tag_128:
        /* "<stdin>":42067:42077   */
      dup1
        /* "<stdin>":42063:42065   */
      0x40
        /* "<stdin>":42056:42078   */
      mstore
      pop
        /* "<stdin>":41814:42092   */
      pop
      pop
    tag_127:
      jump	// out
        /* "<stdin>":43056:44617   */
    tag_21:
        /* "<stdin>":43119:43127   */
      0x00
      dup1
        /* "<stdin>":19398:19409   */
      mload
        /* "<stdin>":22787:22800   */
      0x7350906400000000000000000000000000000000000000000000000000000000
      dup1
      dup4
        /* "<stdin>":19414:19434   */
      mstore
        /* "<stdin>":19464:19468   */
      0x20
      dup4
        /* "<stdin>":19458:19459   */
      0x04
      dup6
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
      dup3
        /* "<stdin>":19479:19487   */
      mload
        /* "<stdin>":19502:19507   */
      dup3
      dup5
        /* "<stdin>":19492:19508   */
      mstore
        /* "<stdin>":39431:39473   */
      sub(shl(0xa0, 0x01), 0x01)
        /* "<stdin>":39192:39197   */
      dup2
        /* "<stdin>":39420:39474   */
      and
      dup5
        /* "<stdin>":52982:53032   */
      mstore
      pop
        /* "<stdin>":43348:43352   */
      0x01
        /* "<stdin>":19464:19468   */
      0x20
        /* "<stdin>":53049:53067   */
      mstore
        /* "<stdin>":43860:43926   */
      tag_130
        /* "<stdin>":43917:43925   */
      dup6
        /* "<stdin>":43752:43843   */
      tag_131
        /* "<stdin>":43834:43842   */
      dup7
        /* "<stdin>":53109:53113   */
      0x40
      dup8
        /* "<stdin>":53096:53114   */
      keccak256
        /* "<stdin>":43752:43843   */
      tag_45
      jump	// in
    tag_131:
        /* "<stdin>":43860:43926   */
      tag_132
      jump	// in
    tag_130:
      dup3
        /* "<stdin>":19398:19409   */
      mload
        /* "<stdin>":19385:19409   */
      swap2
      pop
        /* "<stdin>":22787:22800   */
      dup1
      dup4
        /* "<stdin>":19414:19434   */
      mstore
      pop
        /* "<stdin>":19464:19468   */
      0x20
      dup3
        /* "<stdin>":19458:19459   */
      0x04
      dup5
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
      dup2
        /* "<stdin>":19479:19487   */
      mload
        /* "<stdin>":19502:19507   */
      dup2
      dup4
        /* "<stdin>":19492:19508   */
      mstore
        /* "<stdin>":53109:53113   */
      0x40
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":44304:44335   */
      swap2
      pop
        /* "<stdin>":35296:35301   */
      dup5
        /* "<stdin>":35273:35276   */
      dup3
        /* "<stdin>":35266:35303   */
      mstore
        /* "<stdin>":44496:44504   */
      dup4
        /* "<stdin>":44486:44494   */
      dup2
        /* "<stdin>":44199:44265   */
      0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
        /* "<stdin>":19464:19468   */
      0x20
        /* "<stdin>":44460:44463   */
      dup6
        /* "<stdin>":44455:44505   */
      log3
      pop
      pop
        /* "<stdin>":43348:43352   */
      0x01
        /* "<stdin>":44560:44580   */
      swap1
      pop
        /* "<stdin>":43128:44617   */
    tag_129:
      swap3
      swap2
      pop
      pop
      jump	// out
        /* "<stdin>":44631:45236   */
    tag_50:
        /* "<stdin>":44675:44682   */
      0x00
        /* "<stdin>":24193:24225   */
      tag_134
        /* "<stdin>":44968:45057   */
      tag_135
        /* "<stdin>":45049:45056   */
      dup4
        /* "<stdin>":44968:45057   */
      tag_136
      jump	// in
    tag_135:
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_134:
        /* "<stdin>":45181:45199   */
      swap1
      pop
        /* "<stdin>":44683:45236   */
    tag_133:
      swap2
      swap1
      pop
      jump	// out
        /* "<stdin>":45250:48949   */
    tag_32:
        /* "<stdin>":45328:45336   */
      0x00
        /* "<stdin>":45976:46003   */
      dup4
        /* "<stdin>":24193:24225   */
      tag_138
        /* "<stdin>":45623:45714   */
      tag_139
        /* "<stdin>":45705:45713   */
      dup5
        /* "<stdin>":45623:45714   */
      tag_136
      jump	// in
    tag_139:
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_138:
        /* "<stdin>":45944:46004   */
      lt
        /* "<stdin>":55819:55821   */
      iszero
      tag_140
      jumpi
        /* "<stdin>":37613:37615   */
      0x40
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":55932:55998   */
      shl(0xe5, 0x461bcd)
        /* "<stdin>":55924:55930   */
      dup2
        /* "<stdin>":55917:55999   */
      mstore
        /* "<stdin>":36579:36581   */
      0x20
        /* "<stdin>":56176:56177   */
      0x04
        /* "<stdin>":56168:56174   */
      dup3
        /* "<stdin>":56164:56178   */
      add
        /* "<stdin>":36600:36647   */
      mstore
        /* "<stdin>":34594:34596   */
      0x4f
        /* "<stdin>":36564:36582   */
      0x24
        /* "<stdin>":56168:56174   */
      dup3
        /* "<stdin>":36564:36582   */
      add
        /* "<stdin>":38064:38083   */
      mstore
        /* "<stdin>":58087:58121   */
      0x43616e2774207472616e736665722066726f6d20746865206465736972656420
        /* "<stdin>":38115:38129   */
      0x44
        /* "<stdin>":56168:56174   */
      dup3
        /* "<stdin>":38115:38129   */
      add
        /* "<stdin>":58064:58122   */
      mstore
        /* "<stdin>":58164:58198   */
      0x6163636f756e74206265636175736520697420646f65736e2774206861766520
        /* "<stdin>":58147:58162   */
      0x64
        /* "<stdin>":56168:56174   */
      dup3
        /* "<stdin>":58147:58162   */
      add
        /* "<stdin>":58140:58199   */
      mstore
        /* "<stdin>":58241:58258   */
      0x656e6f7567682062616c616e63652e0000000000000000000000000000000000
        /* "<stdin>":58224:58239   */
      0x84
        /* "<stdin>":56168:56174   */
      dup3
        /* "<stdin>":58224:58239   */
      add
        /* "<stdin>":58217:58259   */
      mstore
        /* "<stdin>":56201:56237   */
      tag_141
        /* "<stdin>":56212:56218   */
      dup2
        /* "<stdin>":56201:56237   */
      tag_73
      jump	// in
    tag_141:
      pop
        /* "<stdin>":55819:55821   */
    tag_140:
        /* "<stdin>":46300:46416   */
      tag_142
        /* "<stdin>":46407:46415   */
      dup3
        /* "<stdin>":46300:46416   */
      tag_60
      jump	// in
    tag_142:
        /* "<stdin>":46955:47060   */
      tag_143
        /* "<stdin>":46909:46936   */
      dup6
        /* "<stdin>":24193:24225   */
      tag_144
        /* "<stdin>":46556:46647   */
      tag_145
        /* "<stdin>":22775:22801   */
      tag_146
      tag_66
      jump	// in
    tag_146:
        /* "<stdin>":46629:46637   */
      dup6
        /* "<stdin>":46556:46647   */
      tag_45
      jump	// in
    tag_145:
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_144:
        /* "<stdin>":46877:46937   */
      lt
        /* "<stdin>":46870:46938   */
      iszero
        /* "<stdin>":46955:47060   */
      tag_147
      jump	// in
    tag_143:
      pop
        /* "<stdin>":47310:47401   */
      tag_148
        /* "<stdin>":47392:47400   */
      dup4
        /* "<stdin>":47310:47401   */
      tag_136
      jump	// in
    tag_148:
        /* "<stdin>":47558:47624   */
      tag_149
        /* "<stdin>":47505:47541   */
      tag_150
        /* "<stdin>":47532:47540   */
      dup7
        /* "<stdin>":24193:24225   */
      tag_151
        /* "<stdin>":47472:47475   */
      dup5
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_151:
        /* "<stdin>":47505:47541   */
      tag_117
      jump	// in
    tag_150:
        /* "<stdin>":47610:47613   */
      dup3
        /* "<stdin>":47558:47624   */
      tag_132
      jump	// in
    tag_149:
      pop
        /* "<stdin>":47917:48008   */
      tag_152
        /* "<stdin>":47999:48007   */
      dup3
        /* "<stdin>":47917:48008   */
      tag_136
      jump	// in
    tag_152:
        /* "<stdin>":48165:48231   */
      tag_153
        /* "<stdin>":48112:48148   */
      tag_154
        /* "<stdin>":48139:48147   */
      dup7
        /* "<stdin>":24193:24225   */
      tag_155
        /* "<stdin>":48079:48082   */
      dup5
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_155:
        /* "<stdin>":48112:48148   */
      tag_122
      jump	// in
    tag_154:
        /* "<stdin>":48217:48220   */
      dup3
        /* "<stdin>":48165:48231   */
      tag_132
      jump	// in
    tag_153:
      pop
        /* "<stdin>":37613:37615   */
      0x40
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":48828:48836   */
      dup4
        /* "<stdin>":48818:48826   */
      dup4
        /* "<stdin>":48531:48597   */
      0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
        /* "<stdin>":48806:48809   */
      dup4
        /* "<stdin>":48699:48766   */
      tag_156
        /* "<stdin>":48757:48765   */
      dup10
        /* "<stdin>":48751:48754   */
      dup7
        /* "<stdin>":48699:48766   */
      tag_28
      jump	// in
    tag_156:
        /* "<stdin>":48797:48810   */
      sub
        /* "<stdin>":48792:48795   */
      dup5
        /* "<stdin>":48787:48837   */
      log3
      pop
        /* "<stdin>":46155:46159   */
      0x01
        /* "<stdin>":48892:48912   */
      swap1
      pop
        /* "<stdin>":45337:48949   */
    tag_137:
      swap4
      swap3
      pop
      pop
      pop
      jump	// out
        /* "<stdin>":48963:51566   */
    tag_54:
        /* "<stdin>":49020:49027   */
      0x00
      dup1
        /* "<stdin>":19398:19409   */
      mload
        /* "<stdin>":22787:22800   */
      0x7350906400000000000000000000000000000000000000000000000000000000
      dup3
        /* "<stdin>":19414:19434   */
      mstore
        /* "<stdin>":19464:19468   */
      0x20
      dup3
        /* "<stdin>":19458:19459   */
      0x04
      dup5
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
      dup2
        /* "<stdin>":19479:19487   */
      mload
        /* "<stdin>":19502:19507   */
      dup2
      dup4
        /* "<stdin>":19492:19508   */
      mstore
        /* "<stdin>":49635:49642   */
      dup5
        /* "<stdin>":24193:24225   */
      tag_158
        /* "<stdin>":49274:49363   */
      tag_159
        /* "<stdin>":22775:22801   */
      dup4
        /* "<stdin>":49274:49363   */
      tag_136
      jump	// in
    tag_159:
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_158:
        /* "<stdin>":49586:49644   */
      lt
        /* "<stdin>":56418:56420   */
      iszero
      tag_160
      jumpi
        /* "<stdin>":37613:37615   */
      0x40
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":56461:56495   */
      swap2
      pop
        /* "<stdin>":55932:55998   */
      shl(0xe5, 0x461bcd)
        /* "<stdin>":56523:56529   */
      dup3
        /* "<stdin>":56516:56598   */
      mstore
        /* "<stdin>":19464:19468   */
      0x20
        /* "<stdin>":19458:19459   */
      0x04
        /* "<stdin>":56767:56773   */
      dup4
        /* "<stdin>":56763:56777   */
      add
        /* "<stdin>":37056:37103   */
      mstore
        /* "<stdin>":35006:35008   */
      0x34
        /* "<stdin>":37020:37038   */
      0x24
        /* "<stdin>":56767:56773   */
      dup4
        /* "<stdin>":37020:37038   */
      add
        /* "<stdin>":38064:38083   */
      mstore
        /* "<stdin>":58436:58470   */
      0x596f7520646f6e2774206861766520656e6f7567682062616c616e636520746f
        /* "<stdin>":38115:38129   */
      0x44
        /* "<stdin>":56767:56773   */
      dup4
        /* "<stdin>":38115:38129   */
      add
        /* "<stdin>":58413:58471   */
      mstore
        /* "<stdin>":58513:58535   */
      0x206d616b652074686973207472616e7366657221000000000000000000000000
        /* "<stdin>":58496:58511   */
      0x64
        /* "<stdin>":56767:56773   */
      dup4
        /* "<stdin>":58496:58511   */
      add
        /* "<stdin>":58489:58536   */
      mstore
        /* "<stdin>":56800:56836   */
      tag_161
        /* "<stdin>":56811:56817   */
      dup3
        /* "<stdin>":56800:56836   */
      tag_76
      jump	// in
    tag_161:
        /* "<stdin>":56418:56420   */
    tag_160:
      pop
      pop
        /* "<stdin>":49982:50071   */
      tag_162
        /* "<stdin>":22775:22801   */
      tag_163
      tag_66
      jump	// in
    tag_163:
        /* "<stdin>":49982:50071   */
      tag_136
      jump	// in
    tag_162:
        /* "<stdin>":50226:50291   */
      tag_164
        /* "<stdin>":50174:50209   */
      tag_165
        /* "<stdin>":50201:50208   */
      dup6
        /* "<stdin>":24193:24225   */
      tag_166
        /* "<stdin>":50142:50145   */
      dup5
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_166:
        /* "<stdin>":50174:50209   */
      tag_122
      jump	// in
    tag_165:
        /* "<stdin>":50278:50281   */
      dup3
        /* "<stdin>":50226:50291   */
      tag_132
      jump	// in
    tag_164:
      pop
        /* "<stdin>":50575:50664   */
      tag_167
        /* "<stdin>":50656:50663   */
      dup3
        /* "<stdin>":50575:50664   */
      tag_136
      jump	// in
    tag_167:
        /* "<stdin>":50819:50884   */
      tag_168
        /* "<stdin>":50767:50802   */
      tag_169
        /* "<stdin>":50794:50801   */
      dup6
        /* "<stdin>":24193:24225   */
      tag_170
        /* "<stdin>":50735:50738   */
      dup5
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_170:
        /* "<stdin>":50767:50802   */
      tag_117
      jump	// in
    tag_169:
        /* "<stdin>":50871:50874   */
      dup3
        /* "<stdin>":50819:50884   */
      tag_132
      jump	// in
    tag_168:
      pop
        /* "<stdin>":22775:22801   */
      tag_171
      tag_66
      jump	// in
    tag_171:
        /* "<stdin>":37613:37615   */
      0x40
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":51446:51454   */
      dup4
        /* "<stdin>":51436:51444   */
      dup3
        /* "<stdin>":51149:51215   */
      0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
        /* "<stdin>":51424:51427   */
      dup4
        /* "<stdin>":51317:51384   */
      tag_172
        /* "<stdin>":51375:51383   */
      dup10
        /* "<stdin>":51369:51372   */
      dup7
        /* "<stdin>":51317:51384   */
      tag_28
      jump	// in
    tag_172:
        /* "<stdin>":51415:51428   */
      sub
        /* "<stdin>":51410:51413   */
      dup5
        /* "<stdin>":51405:51455   */
      log3
      pop
      pop
        /* "<stdin>":51489:51493   */
      0x01
        /* "<stdin>":51510:51529   */
      swap1
      pop
        /* "<stdin>":49028:51566   */
    tag_157:
      swap3
      swap2
      pop
      pop
      jump	// out
        /* "<stdin>":52055:52371   */
    tag_37:
        /* "<stdin>":52097:52100   */
      0x00
        /* "<stdin>":24193:24225   */
      tag_174
        /* "<stdin>":52191:52276   */
      tag_175
        /* "<stdin>":52270:52275   */
      dup4
        /* "<stdin>":52191:52276   */
      tag_136
      jump	// in
    tag_175:
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_174:
      dup2
        /* "<stdin>":41519:41533   */
      0x03
      shl
        /* "<stdin>":57538:57554   */
      shr
        /* "<stdin>":52294:52356   */
      swap1
      pop
        /* "<stdin>":52101:52371   */
    tag_173:
      swap2
      swap1
      pop
      jump	// out
        /* "<stdin>":52833:53128   */
    tag_44:
        /* "<stdin>":52955:52963   */
      0x00
        /* "<stdin>":39431:39473   */
      sub(shl(0xa0, 0x01), 0x01)
        /* "<stdin>":39192:39197   */
      dup3
        /* "<stdin>":39420:39474   */
      and
      dup2
        /* "<stdin>":52982:53032   */
      mstore
        /* "<stdin>":51666:51667   */
      0x01
        /* "<stdin>":53056:53060   */
      0x20
        /* "<stdin>":53049:53067   */
      mstore
        /* "<stdin>":53109:53113   */
      0x40
      dup2
        /* "<stdin>":53096:53114   */
      keccak256
        /* "<stdin>":53084:53114   */
      swap1
      pop
        /* "<stdin>":52964:53128   */
    tag_176:
      swap2
      swap1
      pop
      jump	// out
        /* "<stdin>":52833:53128   */
    tag_60:
        /* "<stdin>":52955:52963   */
      0x00
        /* "<stdin>":39431:39473   */
      sub(shl(0xa0, 0x01), 0x01)
        /* "<stdin>":39192:39197   */
      dup3
        /* "<stdin>":39420:39474   */
      and
      dup2
        /* "<stdin>":52982:53032   */
      mstore
        /* "<stdin>":42329:42333   */
      0x01
        /* "<stdin>":53056:53060   */
      0x20
        /* "<stdin>":53049:53067   */
      mstore
        /* "<stdin>":53109:53113   */
      0x40
      dup2
        /* "<stdin>":53096:53114   */
      keccak256
        /* "<stdin>":53084:53114   */
      swap1
      pop
        /* "<stdin>":52964:53128   */
    tag_177:
      swap2
      swap1
      pop
      jump	// out
        /* "<stdin>":52833:53128   */
    tag_136:
        /* "<stdin>":52955:52963   */
      0x00
        /* "<stdin>":39431:39473   */
      sub(shl(0xa0, 0x01), 0x01)
        /* "<stdin>":39192:39197   */
      dup3
        /* "<stdin>":39420:39474   */
      and
      dup2
        /* "<stdin>":52982:53032   */
      mstore
      dup1
        /* "<stdin>":53056:53060   */
      0x20
        /* "<stdin>":53049:53067   */
      mstore
        /* "<stdin>":53109:53113   */
      0x40
      dup2
        /* "<stdin>":53096:53114   */
      keccak256
        /* "<stdin>":53084:53114   */
      swap1
      pop
        /* "<stdin>":52964:53128   */
    tag_178:
      swap2
      swap1
      pop
      jump	// out
        /* "<stdin>":52833:53128   */
    tag_45:
        /* "<stdin>":52955:52963   */
      0x00
        /* "<stdin>":39431:39473   */
      sub(shl(0xa0, 0x01), 0x01)
        /* "<stdin>":39192:39197   */
      dup4
        /* "<stdin>":39420:39474   */
      and
      dup2
        /* "<stdin>":52982:53032   */
      mstore
        /* "<stdin>":53062:53066   */
      dup2
        /* "<stdin>":53056:53060   */
      0x20
        /* "<stdin>":53049:53067   */
      mstore
        /* "<stdin>":53109:53113   */
      0x40
      dup2
        /* "<stdin>":53096:53114   */
      keccak256
        /* "<stdin>":53084:53114   */
      swap1
      pop
        /* "<stdin>":52964:53128   */
    tag_179:
      swap3
      swap2
      pop
      pop
      jump	// out
        /* "<stdin>":53656:53872   */
    tag_121:
        /* "<stdin>":54172:54249   */
      shl(0xe0, 0x4e487b71)
        /* "<stdin>":53709:53710   */
      0x00
        /* "<stdin>":53702:53790   */
      mstore
        /* "<stdin>":53817:53821   */
      0x11
        /* "<stdin>":53814:53815   */
      0x04
        /* "<stdin>":53807:53822   */
      mstore
        /* "<stdin>":23850:23859   */
      invalid
        /* "<stdin>":53684:53872   */
    tag_180:
      jump	// out
        /* "<stdin>":54451:54689   */
    tag_15:
        /* "<stdin>":54530:54535   */
      0x00
      dup1
        /* "<stdin>":54557:54570   */
      iszero
      iszero
        /* "<stdin>":54554:54556   */
      iszero
      tag_182
      jumpi
        /* "<stdin>":54172:54249   */
      shl(0xe0, 0x4e487b71)
      dup2
        /* "<stdin>":53472:53560   */
      mstore
      dup1
        /* "<stdin>":53584:53585   */
      0x04
        /* "<stdin>":53577:53592   */
      mstore
        /* "<stdin>":23850:23859   */
      invalid
        /* "<stdin>":54554:54556   */
    tag_182:
        /* "<stdin>":37613:37615   */
      0x40
        /* "<stdin>":37607:37616   */
      mload
      dup2
        /* "<stdin>":24193:24225   */
      tag_183
      tag_69
      jump	// in
    tag_183:
      dup4
        /* "<stdin>":41023:41035   */
      0x01
        /* "<stdin>":41027:41031   */
      dup3
        /* "<stdin>":41023:41035   */
      dup2
      shr
        /* "<stdin>":41013:41035   */
      swap2
      pop
        /* "<stdin>":41023:41035   */
      dup1
        /* "<stdin>":41082:41086   */
      dup4
        /* "<stdin>":41078:41090   */
      and
        /* "<stdin>":41117:41135   */
      dup1
        /* "<stdin>":41110:41136   */
      iszero
        /* "<stdin>":41107:41109   */
      iszero
      tag_184
      jumpi
        /* "<stdin>":41181:41185   */
      0x7f
        /* "<stdin>":41173:41179   */
      dup4
        /* "<stdin>":41169:41186   */
      and
        /* "<stdin>":41159:41186   */
      swap3
      pop
        /* "<stdin>":41107:41109   */
    tag_184:
        /* "<stdin>":41259:41261   */
      0x20
      dup1
        /* "<stdin>":41251:41257   */
      dup5
        /* "<stdin>":41248:41262   */
      lt
        /* "<stdin>":41228:41246   */
      dup3
        /* "<stdin>":41225:41263   */
      eq
        /* "<stdin>":41222:41224   */
      iszero
      tag_185
      jumpi
        /* "<stdin>":54172:54249   */
      shl(0xe0, 0x4e487b71)
      dup9
        /* "<stdin>":53932:54020   */
      mstore
        /* "<stdin>":54047:54051   */
      0x22
        /* "<stdin>":54044:54045   */
      0x04
        /* "<stdin>":54037:54052   */
      mstore
        /* "<stdin>":23850:23859   */
      invalid
        /* "<stdin>":41222:41224   */
    tag_185:
        /* "<stdin>":33204:33265   */
      tag_186
        /* "<stdin>":33258:33264   */
      dup5
        /* "<stdin>":33253:33256   */
      dup9
        /* "<stdin>":33204:33265   */
      tag_115
      jump	// in
    tag_186:
        /* "<stdin>":33289:33306   */
      dup3
        /* "<stdin>":33328:33329   */
      0x00
        /* "<stdin>":33323:33490   */
      dup2
      eq
      tag_188
      jumpi
        /* "<stdin>":33512:33513   */
      0x01
        /* "<stdin>":33507:33919   */
      dup2
      eq
      tag_189
      jumpi
        /* "<stdin>":33282:33919   */
      jump(tag_187)
        /* "<stdin>":33323:33490   */
    tag_188:
        /* "<stdin>":33419:33428   */
      not(0xff)
        /* "<stdin>":33408:33417   */
      dup8
        /* "<stdin>":33404:33429   */
      and
        /* "<stdin>":33399:33402   */
      dup3
        /* "<stdin>":33392:33430   */
      mstore
        /* "<stdin>":41259:41261   */
      dup3
        /* "<stdin>":33462:33465   */
      dup3
        /* "<stdin>":33458:33472   */
      add
        /* "<stdin>":33451:33472   */
      swap8
      pop
        /* "<stdin>":33323:33490   */
      jump(tag_187)
        /* "<stdin>":33507:33919   */
    tag_189:
        /* "<stdin>":33590:33628   */
      tag_190
      tag_113
      jump	// in
    tag_190:
      dup11
        /* "<stdin>":33680:33862   */
    tag_191:
        /* "<stdin>":33694:33700   */
      dup8
        /* "<stdin>":33691:33692   */
      dup2
        /* "<stdin>":33688:33701   */
      lt
        /* "<stdin>":33680:33862   */
      iszero
      tag_193
      jumpi
        /* "<stdin>":24193:24225   */
      tag_194
        /* "<stdin>":33780:33787   */
      dup3
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_194:
        /* "<stdin>":33766:33767   */
      dup2
        /* "<stdin>":33761:33764   */
      dup6
        /* "<stdin>":33757:33768   */
      add
        /* "<stdin>":33750:33789   */
      mstore
        /* "<stdin>":41023:41035   */
      dup7
        /* "<stdin>":33829:33836   */
      dup3
        /* "<stdin>":33825:33840   */
      add
        /* "<stdin>":33814:33840   */
      swap2
      pop
        /* "<stdin>":33680:33862   */
    tag_192:
        /* "<stdin>":41259:41261   */
      dup5
        /* "<stdin>":33713:33714   */
      dup2
        /* "<stdin>":33709:33721   */
      add
        /* "<stdin>":33704:33721   */
      swap1
      pop
        /* "<stdin>":33680:33862   */
      jump(tag_191)
    tag_193:
        /* "<stdin>":33899:33900   */
      dup1
        /* "<stdin>":33894:33897   */
      dup5
        /* "<stdin>":33890:33901   */
      add
        /* "<stdin>":33883:33901   */
      swap10
      pop
      pop
      pop
        /* "<stdin>":33282:33919   */
    tag_187:
      pop
      pop
      pop
      pop
      pop
      pop
      pop
        /* "<stdin>":40462:40507   */
      tag_195
        /* "<stdin>":40499:40505   */
      dup3
        /* "<stdin>":32303:32366   */
      dup3
        /* "<stdin>":40490:40506   */
      sub
        /* "<stdin>":40482:40488   */
      dup4
        /* "<stdin>":40462:40507   */
      tag_126
      jump	// in
    tag_195:
      pop
        /* "<stdin>":54610:54675   */
      dup1
      swap2
      pop
      pop
        /* "<stdin>":54536:54689   */
    tag_181:
      swap1
      jump	// out
        /* "<stdin>":54703:54887   */
    tag_46:
        /* "<stdin>":54771:54776   */
      0x00
        /* "<stdin>":24193:24225   */
      tag_197
        /* "<stdin>":54858:54862   */
      dup3
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_197:
      dup2
        /* "<stdin>":41519:41533   */
      0x03
      shl
        /* "<stdin>":57538:57554   */
      shr
        /* "<stdin>":54795:54872   */
      swap1
      pop
        /* "<stdin>":54777:54887   */
    tag_196:
      swap2
      swap1
      pop
      jump	// out
        /* "<stdin>":55085:55670   */
    tag_147:
        /* "<stdin>":55230:55239   */
      dup1
        /* "<stdin>":55223:55240   */
      iszero
        /* "<stdin>":55220:55222   */
      iszero
      tag_199
      jumpi
        /* "<stdin>":37613:37615   */
      0x40
        /* "<stdin>":37607:37616   */
      mload
        /* "<stdin>":55932:55998   */
      shl(0xe5, 0x461bcd)
        /* "<stdin>":55325:55331   */
      dup2
        /* "<stdin>":55318:55400   */
      mstore
        /* "<stdin>":36123:36125   */
      0x20
        /* "<stdin>":55577:55578   */
      0x04
        /* "<stdin>":55569:55575   */
      dup3
        /* "<stdin>":55565:55579   */
      add
        /* "<stdin>":36144:36191   */
      mstore
        /* "<stdin>":34182:34184   */
      0x56
        /* "<stdin>":36108:36126   */
      0x24
        /* "<stdin>":55569:55575   */
      dup3
        /* "<stdin>":36108:36126   */
      add
        /* "<stdin>":38064:38083   */
      mstore
        /* "<stdin>":57731:57765   */
      0x43616e2774207472616e736665722066726f6d20746865206465736972656420
        /* "<stdin>":38115:38129   */
      0x44
        /* "<stdin>":55569:55575   */
      dup3
        /* "<stdin>":38115:38129   */
      add
        /* "<stdin>":57708:57766   */
      mstore
        /* "<stdin>":57808:57842   */
      0x6163636f756e74206265636175736520796f7520646f6e277420686176652065
        /* "<stdin>":57791:57806   */
      0x64
        /* "<stdin>":55569:55575   */
      dup3
        /* "<stdin>":57791:57806   */
      add
        /* "<stdin>":57784:57843   */
      mstore
        /* "<stdin>":57885:57909   */
      0x6e6f756768206f6620616e20616c6c6f77616e63652e00000000000000000000
        /* "<stdin>":57868:57883   */
      0x84
        /* "<stdin>":55569:55575   */
      dup3
        /* "<stdin>":57868:57883   */
      add
        /* "<stdin>":57861:57910   */
      mstore
        /* "<stdin>":55602:55638   */
      tag_200
        /* "<stdin>":55613:55619   */
      dup2
        /* "<stdin>":55602:55638   */
      tag_73
      jump	// in
    tag_200:
      pop
        /* "<stdin>":55220:55222   */
    tag_199:
        /* "<stdin>":55202:55670   */
      pop
    tag_198:
      jump	// out
        /* "<stdin>":58909:59203   */
    tag_132:
        /* "<stdin>":24193:24225   */
      tag_202
        /* "<stdin>":59139:59143   */
      dup2
        /* "<stdin>":24193:24225   */
      tag_61
      jump	// in
    tag_202:
      pop
      0x00
      dup1
        /* "<stdin>":19053:19064   */
      mload
        /* "<stdin>":19088:19092   */
      0x20
        /* "<stdin>":19082:19093   */
      mload
        /* "<stdin>":19117:19121   */
      0x40
        /* "<stdin>":19111:19122   */
      mload
        /* "<stdin>":24273:24286   */
      0x22bd64c000000000000000000000000000000000000000000000000000000000
      dup5
        /* "<stdin>":19127:19147   */
      mstore
        /* "<stdin>":19162:19163   */
      dup5
        /* "<stdin>":19159:19160   */
      0x04
        /* "<stdin>":19152:19164   */
      mstore
        /* "<stdin>":19182:19183   */
      dup6
        /* "<stdin>":19176:19180   */
      0x24
        /* "<stdin>":19169:19184   */
      mstore
      dup4
      dup5
        /* "<stdin>":19208:19212   */
      0x44
      dup7
      verbatimbytecode_336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b
        /* "<stdin>":19237:19242   */
      dup3
      dup5
        /* "<stdin>":19224:19243   */
      mstore
        /* "<stdin>":19261:19266   */
      dup2
        /* "<stdin>":19088:19092   */
      0x20
        /* "<stdin>":19248:19267   */
      mstore
        /* "<stdin>":19285:19290   */
      dup1
        /* "<stdin>":19117:19121   */
      0x40
        /* "<stdin>":19272:19291   */
      mstore
      pop
      pop
      pop
      pop
        /* "<stdin>":58985:59203   */
      pop
      pop
    tag_201:
      jump	// out
    tag_65:
}

